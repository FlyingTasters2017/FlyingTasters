/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dummy_integration.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Int32_Initialize(T_Int32* pVal)
{
    *pVal = (T_Int32) -2147483648LL;
}
#endif

 
flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_T_Int32;

	return ret;
}

flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : 268435457;

	return ret;
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
    *pErrCode = ret ? 0 : 268435458;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_UInt32_Initialize(T_UInt32* pVal)
{
    *pVal = (T_UInt32) 0;
}
#endif

 
flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_T_UInt32;

	return ret;
}

flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
    *pErrCode = ret ? 0 : 268435460;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Int8_Initialize(T_Int8* pVal)
{
    *pVal = (T_Int8) -128;
}
#endif

 
flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_T_Int8;

	return ret;
}

flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : 268435461;

	return ret;
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
    *pErrCode = ret ? 0 : 268435462;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ReferenceFormation_nodes_Initialize(ReferenceFormation_nodes* pVal)
{
    *pVal = (ReferenceFormation_nodes) {    .arr = 
    {
        -128        
    }
};
}
#endif

 
flag ReferenceFormation_nodes_IsConstraintValid(const ReferenceFormation_nodes* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 5)) {
	    ret = T_Int8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag ReferenceFormation_nodes_Equal(const ReferenceFormation_nodes* pVal1, const ReferenceFormation_nodes* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<5; i1++) 
	{
		ret = T_Int8_Equal(&pVal1->arr[i1], &pVal2->arr[i1]);
	}

	return ret;
}

flag ReferenceFormation_nodes_Encode(const ReferenceFormation_nodes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? ReferenceFormation_nodes_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int8_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferenceFormation_nodes_Decode(ReferenceFormation_nodes* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)5) && ret; i1++) 
	{
		ret = T_Int8_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag ReferenceFormation_nodes_ACN_Encode(const ReferenceFormation_nodes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? ReferenceFormation_nodes_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)5) && ret; i1++) 
	    {
	    	ret = T_Int8_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferenceFormation_nodes_ACN_Decode(ReferenceFormation_nodes* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)5) && ret; i1++) 
    {
    	ret = T_Int8_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_UInt8_Initialize(T_UInt8* pVal)
{
    *pVal = (T_UInt8) 0;
}
#endif

 
flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_T_UInt8;

	return ret;
}

flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : 268435463;

	return ret;
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : 268435464;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyInteger_Initialize(MyInteger* pVal)
{
    *pVal = (MyInteger) 0;
}
#endif

 
flag MyInteger_IsConstraintValid(const MyInteger* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_UInt8_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag MyInteger_Equal(const MyInteger* pVal1, const MyInteger* pVal2)
{
	flag ret=TRUE;
	
	ret = T_UInt8_Equal(pVal1, pVal2);

	return ret;
}

flag MyInteger_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag MyInteger_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag MyInteger_ACN_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt8_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag MyInteger_ACN_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Boolean_Initialize(T_Boolean* pVal)
{
    *pVal = (T_Boolean) FALSE;
}
#endif

 
flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (*pVal1 && *pVal2) || (!*pVal1 && !*pVal2));

	return ret;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435465;

	return ret;
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435466;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyReal_Initialize(MyReal* pVal)
{
    *pVal = (MyReal) 0.00000000000000000000E+000;
}
#endif

 
flag MyReal_IsConstraintValid(const MyReal* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-1.00000000000000000000E+003 <= *pVal && *pVal <= 1.00000000000000000000E+005);
	*pErrCode = ret ? 0 : ERR_MyReal;

	return ret;
}

flag MyReal_Equal(const MyReal* pVal1, const MyReal* pVal2)
{
	flag ret=TRUE;
	
	ret =  *pVal1 == *pVal2 ? TRUE : (*pVal1 == 0.0 ? *pVal2 ==0.0 : (fabs((*pVal1 - *pVal2) / *pVal1) < 0.00001));

	return ret;
}

flag MyReal_Encode(const MyReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, *pVal);
    }

	return ret;
}

flag MyReal_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435467;

	return ret;
}

flag MyReal_ACN_Encode(const MyReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, *pVal);
    }

	return ret;
}

flag MyReal_ACN_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    BitStream_DecodeReal(pBitStrm, pVal);
    *pErrCode = ret ? 0 : 268435468;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void PositionSystemData_Initialize(PositionSystemData* pVal)
{
    *pVal = (PositionSystemData) {
    .xAct = 0.00000000000000000000E+000,
    .yAct = 0.00000000000000000000E+000
};
}
#endif

 
flag PositionSystemData_IsConstraintValid(const PositionSystemData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->xAct, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->yAct, pErrCode);
	
	}

	return ret;
}

flag PositionSystemData_Equal(const PositionSystemData* pVal1, const PositionSystemData* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->xAct, &pVal2->xAct);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->yAct, &pVal2->yAct);
	
	}

	return ret;
}

flag PositionSystemData_Encode(const PositionSystemData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? PositionSystemData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode xAct */
	    ret = MyReal_Encode(&pVal->xAct, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode yAct */
	        ret = MyReal_Encode(&pVal->yAct, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag PositionSystemData_Decode(PositionSystemData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode xAct */
	ret = MyReal_Decode(&pVal->xAct, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode yAct */
	    ret = MyReal_Decode(&pVal->yAct, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag PositionSystemData_ACN_Encode(const PositionSystemData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? PositionSystemData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode xAct */
	    ret = MyReal_ACN_Encode(&pVal->xAct, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode yAct */
	        ret = MyReal_ACN_Encode(&pVal->yAct, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag PositionSystemData_ACN_Decode(PositionSystemData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode xAct */
    ret = MyReal_ACN_Decode(&pVal->xAct, pBitStrm, pErrCode);
    if (ret) {
        /*Decode yAct */
        ret = MyReal_ACN_Decode(&pVal->yAct, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void DroneSensorData_Initialize(DroneSensorData* pVal)
{
    *pVal = (DroneSensorData) {
    .yawAct = 0.00000000000000000000E+000,
    .pitchAct = 0.00000000000000000000E+000,
    .rollAct = 0.00000000000000000000E+000,
    .baropAct = 0.00000000000000000000E+000,
    .accxAct = 0.00000000000000000000E+000,
    .accyAct = 0.00000000000000000000E+000,
    .acczAct = 0.00000000000000000000E+000
};
}
#endif

 
flag DroneSensorData_IsConstraintValid(const DroneSensorData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->yawAct, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->pitchAct, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->rollAct, pErrCode);
	        if (ret) {
	            ret = MyReal_IsConstraintValid(&pVal->baropAct, pErrCode);
	            if (ret) {
	                ret = MyReal_IsConstraintValid(&pVal->accxAct, pErrCode);
	                if (ret) {
	                    ret = MyReal_IsConstraintValid(&pVal->accyAct, pErrCode);
	                    if (ret) {
	                        ret = MyReal_IsConstraintValid(&pVal->acczAct, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag DroneSensorData_Equal(const DroneSensorData* pVal1, const DroneSensorData* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->yawAct, &pVal2->yawAct);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->pitchAct, &pVal2->pitchAct);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->rollAct, &pVal2->rollAct);
	        if (ret) {
	            ret = MyReal_Equal(&pVal1->baropAct, &pVal2->baropAct);
	            if (ret) {
	                ret = MyReal_Equal(&pVal1->accxAct, &pVal2->accxAct);
	                if (ret) {
	                    ret = MyReal_Equal(&pVal1->accyAct, &pVal2->accyAct);
	                    if (ret) {
	                        ret = MyReal_Equal(&pVal1->acczAct, &pVal2->acczAct);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag DroneSensorData_Encode(const DroneSensorData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DroneSensorData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yawAct */
	    ret = MyReal_Encode(&pVal->yawAct, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitchAct */
	        ret = MyReal_Encode(&pVal->pitchAct, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rollAct */
	            ret = MyReal_Encode(&pVal->rollAct, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode baropAct */
	                ret = MyReal_Encode(&pVal->baropAct, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode accxAct */
	                    ret = MyReal_Encode(&pVal->accxAct, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode accyAct */
	                        ret = MyReal_Encode(&pVal->accyAct, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode acczAct */
	                            ret = MyReal_Encode(&pVal->acczAct, pBitStrm, pErrCode, FALSE);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag DroneSensorData_Decode(DroneSensorData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode yawAct */
	ret = MyReal_Decode(&pVal->yawAct, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pitchAct */
	    ret = MyReal_Decode(&pVal->pitchAct, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rollAct */
	        ret = MyReal_Decode(&pVal->rollAct, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode baropAct */
	            ret = MyReal_Decode(&pVal->baropAct, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode accxAct */
	                ret = MyReal_Decode(&pVal->accxAct, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode accyAct */
	                    ret = MyReal_Decode(&pVal->accyAct, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode acczAct */
	                        ret = MyReal_Decode(&pVal->acczAct, pBitStrm, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

flag DroneSensorData_ACN_Encode(const DroneSensorData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DroneSensorData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yawAct */
	    ret = MyReal_ACN_Encode(&pVal->yawAct, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitchAct */
	        ret = MyReal_ACN_Encode(&pVal->pitchAct, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rollAct */
	            ret = MyReal_ACN_Encode(&pVal->rollAct, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode baropAct */
	                ret = MyReal_ACN_Encode(&pVal->baropAct, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode accxAct */
	                    ret = MyReal_ACN_Encode(&pVal->accxAct, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode accyAct */
	                        ret = MyReal_ACN_Encode(&pVal->accyAct, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode acczAct */
	                            ret = MyReal_ACN_Encode(&pVal->acczAct, pBitStrm, pErrCode, FALSE);

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag DroneSensorData_ACN_Decode(DroneSensorData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode yawAct */
    ret = MyReal_ACN_Decode(&pVal->yawAct, pBitStrm, pErrCode);
    if (ret) {
        /*Decode pitchAct */
        ret = MyReal_ACN_Decode(&pVal->pitchAct, pBitStrm, pErrCode);
        if (ret) {
            /*Decode rollAct */
            ret = MyReal_ACN_Decode(&pVal->rollAct, pBitStrm, pErrCode);
            if (ret) {
                /*Decode baropAct */
                ret = MyReal_ACN_Decode(&pVal->baropAct, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode accxAct */
                    ret = MyReal_ACN_Decode(&pVal->accxAct, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode accyAct */
                        ret = MyReal_ACN_Decode(&pVal->accyAct, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode acczAct */
                            ret = MyReal_ACN_Decode(&pVal->acczAct, pBitStrm, pErrCode);

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void WorldData_Initialize(WorldData* pVal)
{
    *pVal = (WorldData) {
    .rawASD = {
        .yawAct = 0.00000000000000000000E+000,
        .pitchAct = 0.00000000000000000000E+000,
        .rollAct = 0.00000000000000000000E+000,
        .baropAct = 0.00000000000000000000E+000,
        .accxAct = 0.00000000000000000000E+000,
        .accyAct = 0.00000000000000000000E+000,
        .acczAct = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag WorldData_IsConstraintValid(const WorldData* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DroneSensorData_IsConstraintValid(&pVal->rawASD, pErrCode);


	return ret;
}

flag WorldData_Equal(const WorldData* pVal1, const WorldData* pVal2)
{
	flag ret=TRUE;
	
	ret = DroneSensorData_Equal(&pVal1->rawASD, &pVal2->rawASD);


	return ret;
}

flag WorldData_Encode(const WorldData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? WorldData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rawASD */
	    ret = DroneSensorData_Encode(&pVal->rawASD, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag WorldData_Decode(WorldData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rawASD */
	ret = DroneSensorData_Decode(&pVal->rawASD, pBitStrm, pErrCode);
	


	return ret;
}

flag WorldData_ACN_Encode(const WorldData* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? WorldData_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rawASD */
	    ret = DroneSensorData_ACN_Encode(&pVal->rawASD, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag WorldData_ACN_Decode(WorldData* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode rawASD */
    ret = DroneSensorData_ACN_Decode(&pVal->rawASD, pBitStrm, pErrCode);


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void DroneControllerInput_Initialize(DroneControllerInput* pVal)
{
    *pVal = (DroneControllerInput) {
    .yawrateRef = 0.00000000000000000000E+000,
    .pitchRef = 0.00000000000000000000E+000,
    .rollRef = 0.00000000000000000000E+000,
    .thrustRef = 0.00000000000000000000E+000
};
}
#endif

 
flag DroneControllerInput_IsConstraintValid(const DroneControllerInput* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->yawrateRef, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->pitchRef, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->rollRef, pErrCode);
	        if (ret) {
	            ret = MyReal_IsConstraintValid(&pVal->thrustRef, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag DroneControllerInput_Equal(const DroneControllerInput* pVal1, const DroneControllerInput* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->yawrateRef, &pVal2->yawrateRef);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->pitchRef, &pVal2->pitchRef);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->rollRef, &pVal2->rollRef);
	        if (ret) {
	            ret = MyReal_Equal(&pVal1->thrustRef, &pVal2->thrustRef);
	        
	        }
	    }
	}

	return ret;
}

flag DroneControllerInput_Encode(const DroneControllerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? DroneControllerInput_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yawrateRef */
	    ret = MyReal_Encode(&pVal->yawrateRef, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitchRef */
	        ret = MyReal_Encode(&pVal->pitchRef, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rollRef */
	            ret = MyReal_Encode(&pVal->rollRef, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode thrustRef */
	                ret = MyReal_Encode(&pVal->thrustRef, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag DroneControllerInput_Decode(DroneControllerInput* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode yawrateRef */
	ret = MyReal_Decode(&pVal->yawrateRef, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pitchRef */
	    ret = MyReal_Decode(&pVal->pitchRef, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rollRef */
	        ret = MyReal_Decode(&pVal->rollRef, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode thrustRef */
	            ret = MyReal_Decode(&pVal->thrustRef, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag DroneControllerInput_ACN_Encode(const DroneControllerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DroneControllerInput_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yawrateRef */
	    ret = MyReal_ACN_Encode(&pVal->yawrateRef, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitchRef */
	        ret = MyReal_ACN_Encode(&pVal->pitchRef, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rollRef */
	            ret = MyReal_ACN_Encode(&pVal->rollRef, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode thrustRef */
	                ret = MyReal_ACN_Encode(&pVal->thrustRef, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag DroneControllerInput_ACN_Decode(DroneControllerInput* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode yawrateRef */
    ret = MyReal_ACN_Decode(&pVal->yawrateRef, pBitStrm, pErrCode);
    if (ret) {
        /*Decode pitchRef */
        ret = MyReal_ACN_Decode(&pVal->pitchRef, pBitStrm, pErrCode);
        if (ret) {
            /*Decode rollRef */
            ret = MyReal_ACN_Decode(&pVal->rollRef, pBitStrm, pErrCode);
            if (ret) {
                /*Decode thrustRef */
                ret = MyReal_ACN_Decode(&pVal->thrustRef, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Position_Initialize(Position* pVal)
{
    *pVal = (Position) {
    .x = 0.00000000000000000000E+000,
    .y = 0.00000000000000000000E+000,
    .z = 0.00000000000000000000E+000
};
}
#endif

 
flag Position_IsConstraintValid(const Position* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->x, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->y, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->z, pErrCode);
	    
	    }
	}

	return ret;
}

flag Position_Equal(const Position* pVal1, const Position* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->x, &pVal2->x);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->y, &pVal2->y);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->z, &pVal2->z);
	    
	    }
	}

	return ret;
}

flag Position_Encode(const Position* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Position_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = MyReal_Encode(&pVal->x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = MyReal_Encode(&pVal->y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = MyReal_Encode(&pVal->z, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag Position_Decode(Position* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = MyReal_Decode(&pVal->x, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y */
	    ret = MyReal_Decode(&pVal->y, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z */
	        ret = MyReal_Decode(&pVal->z, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag Position_ACN_Encode(const Position* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Position_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = MyReal_ACN_Encode(&pVal->x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = MyReal_ACN_Encode(&pVal->y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = MyReal_ACN_Encode(&pVal->z, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag Position_ACN_Decode(Position* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode x */
    ret = MyReal_ACN_Decode(&pVal->x, pBitStrm, pErrCode);
    if (ret) {
        /*Decode y */
        ret = MyReal_ACN_Decode(&pVal->y, pBitStrm, pErrCode);
        if (ret) {
            /*Decode z */
            ret = MyReal_ACN_Decode(&pVal->z, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Area_Initialize(Area* pVal)
{
    *pVal = (Area) {
    .height = -128,
    .width = -128,
    .depth = -128,
    .refLocation = {
        .x = 0.00000000000000000000E+000,
        .y = 0.00000000000000000000E+000,
        .z = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag Area_IsConstraintValid(const Area* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_Int8_IsConstraintValid(&pVal->height, pErrCode);
	if (ret) {
	    ret = T_Int8_IsConstraintValid(&pVal->width, pErrCode);
	    if (ret) {
	        ret = T_Int8_IsConstraintValid(&pVal->depth, pErrCode);
	        if (ret) {
	            ret = Position_IsConstraintValid(&pVal->refLocation, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag Area_Equal(const Area* pVal1, const Area* pVal2)
{
	flag ret=TRUE;
	
	ret = T_Int8_Equal(&pVal1->height, &pVal2->height);
	if (ret) {
	    ret = T_Int8_Equal(&pVal1->width, &pVal2->width);
	    if (ret) {
	        ret = T_Int8_Equal(&pVal1->depth, &pVal2->depth);
	        if (ret) {
	            ret = Position_Equal(&pVal1->refLocation, &pVal2->refLocation);
	        
	        }
	    }
	}

	return ret;
}

flag Area_Encode(const Area* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Area_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode height */
	    ret = T_Int8_Encode(&pVal->height, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode width */
	        ret = T_Int8_Encode(&pVal->width, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode depth */
	            ret = T_Int8_Encode(&pVal->depth, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode refLocation */
	                ret = Position_Encode(&pVal->refLocation, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag Area_Decode(Area* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode height */
	ret = T_Int8_Decode(&pVal->height, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode width */
	    ret = T_Int8_Decode(&pVal->width, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode depth */
	        ret = T_Int8_Decode(&pVal->depth, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode refLocation */
	            ret = Position_Decode(&pVal->refLocation, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag Area_ACN_Encode(const Area* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Area_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode height */
	    ret = T_Int8_ACN_Encode(&pVal->height, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode width */
	        ret = T_Int8_ACN_Encode(&pVal->width, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode depth */
	            ret = T_Int8_ACN_Encode(&pVal->depth, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode refLocation */
	                ret = Position_ACN_Encode(&pVal->refLocation, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag Area_ACN_Decode(Area* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode height */
    ret = T_Int8_ACN_Decode(&pVal->height, pBitStrm, pErrCode);
    if (ret) {
        /*Decode width */
        ret = T_Int8_ACN_Decode(&pVal->width, pBitStrm, pErrCode);
        if (ret) {
            /*Decode depth */
            ret = T_Int8_ACN_Decode(&pVal->depth, pBitStrm, pErrCode);
            if (ret) {
                /*Decode refLocation */
                ret = Position_ACN_Decode(&pVal->refLocation, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ReferenceFormation_Initialize(ReferenceFormation* pVal)
{
    *pVal = (ReferenceFormation) {
    .nodes = {    .arr = 
        {
            -128        
        }
    },
    .anchor = -128,
    .formationAnchorPosition = {
        .x = 0.00000000000000000000E+000,
        .y = 0.00000000000000000000E+000,
        .z = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag ReferenceFormation_IsConstraintValid(const ReferenceFormation* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ReferenceFormation_nodes_IsConstraintValid(&pVal->nodes, pErrCode);
	if (ret) {
	    ret = T_Int8_IsConstraintValid(&pVal->anchor, pErrCode);
	    if (ret) {
	        ret = Position_IsConstraintValid(&pVal->formationAnchorPosition, pErrCode);
	    
	    }
	}

	return ret;
}

flag ReferenceFormation_Equal(const ReferenceFormation* pVal1, const ReferenceFormation* pVal2)
{
	flag ret=TRUE;
	
	ret = ReferenceFormation_nodes_Equal(&pVal1->nodes, &pVal2->nodes);
	if (ret) {
	    ret = T_Int8_Equal(&pVal1->anchor, &pVal2->anchor);
	    if (ret) {
	        ret = Position_Equal(&pVal1->formationAnchorPosition, &pVal2->formationAnchorPosition);
	    
	    }
	}

	return ret;
}

flag ReferenceFormation_Encode(const ReferenceFormation* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ReferenceFormation_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode nodes */
	    ret = ReferenceFormation_nodes_Encode(&pVal->nodes, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode anchor */
	        ret = T_Int8_Encode(&pVal->anchor, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode formationAnchorPosition */
	            ret = Position_Encode(&pVal->formationAnchorPosition, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag ReferenceFormation_Decode(ReferenceFormation* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode nodes */
	ret = ReferenceFormation_nodes_Decode(&pVal->nodes, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode anchor */
	    ret = T_Int8_Decode(&pVal->anchor, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode formationAnchorPosition */
	        ret = Position_Decode(&pVal->formationAnchorPosition, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag ReferenceFormation_ACN_Encode(const ReferenceFormation* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? ReferenceFormation_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode nodes */
	    ret = ReferenceFormation_nodes_ACN_Encode(&pVal->nodes, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode anchor */
	        ret = T_Int8_ACN_Encode(&pVal->anchor, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode formationAnchorPosition */
	            ret = Position_ACN_Encode(&pVal->formationAnchorPosition, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag ReferenceFormation_ACN_Decode(ReferenceFormation* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode nodes */
    ret = ReferenceFormation_nodes_ACN_Decode(&pVal->nodes, pBitStrm, pErrCode);
    if (ret) {
        /*Decode anchor */
        ret = T_Int8_ACN_Decode(&pVal->anchor, pBitStrm, pErrCode);
        if (ret) {
            /*Decode formationAnchorPosition */
            ret = Position_ACN_Decode(&pVal->formationAnchorPosition, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ReferencePath_locations_Initialize(ReferencePath_locations* pVal)
{
    *pVal = (ReferencePath_locations) {    .arr = 
    {
        {
            .x = 0.00000000000000000000E+000,
            .y = 0.00000000000000000000E+000,
            .z = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag ReferencePath_locations_IsConstraintValid(const ReferencePath_locations* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 3)) {
	    ret = Position_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag ReferencePath_locations_Equal(const ReferencePath_locations* pVal1, const ReferencePath_locations* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<3; i1++) 
	{
		ret = Position_Equal(&pVal1->arr[i1], &pVal2->arr[i1]);
	}

	return ret;
}

flag ReferencePath_locations_Encode(const ReferencePath_locations* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? ReferencePath_locations_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = Position_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferencePath_locations_Decode(ReferencePath_locations* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = Position_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag ReferencePath_locations_ACN_Encode(const ReferencePath_locations* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? ReferencePath_locations_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = Position_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferencePath_locations_ACN_Decode(ReferencePath_locations* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)3) && ret; i1++) 
    {
    	ret = Position_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Orientation_Initialize(Orientation* pVal)
{
    *pVal = (Orientation) {
    .roll = 0.00000000000000000000E+000,
    .pitch = 0.00000000000000000000E+000,
    .yaw = 0.00000000000000000000E+000
};
}
#endif

 
flag Orientation_IsConstraintValid(const Orientation* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->roll, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->pitch, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->yaw, pErrCode);
	    
	    }
	}

	return ret;
}

flag Orientation_Equal(const Orientation* pVal1, const Orientation* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->roll, &pVal2->roll);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->pitch, &pVal2->pitch);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->yaw, &pVal2->yaw);
	    
	    }
	}

	return ret;
}

flag Orientation_Encode(const Orientation* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Orientation_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode roll */
	    ret = MyReal_Encode(&pVal->roll, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitch */
	        ret = MyReal_Encode(&pVal->pitch, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode yaw */
	            ret = MyReal_Encode(&pVal->yaw, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag Orientation_Decode(Orientation* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode roll */
	ret = MyReal_Decode(&pVal->roll, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pitch */
	    ret = MyReal_Decode(&pVal->pitch, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode yaw */
	        ret = MyReal_Decode(&pVal->yaw, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag Orientation_ACN_Encode(const Orientation* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Orientation_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode roll */
	    ret = MyReal_ACN_Encode(&pVal->roll, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pitch */
	        ret = MyReal_ACN_Encode(&pVal->pitch, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode yaw */
	            ret = MyReal_ACN_Encode(&pVal->yaw, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag Orientation_ACN_Decode(Orientation* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode roll */
    ret = MyReal_ACN_Decode(&pVal->roll, pBitStrm, pErrCode);
    if (ret) {
        /*Decode pitch */
        ret = MyReal_ACN_Decode(&pVal->pitch, pBitStrm, pErrCode);
        if (ret) {
            /*Decode yaw */
            ret = MyReal_ACN_Decode(&pVal->yaw, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Trajectory_Initialize(Trajectory* pVal)
{
    *pVal = (Trajectory) {
    .x = 0.00000000000000000000E+000,
    .y = 0.00000000000000000000E+000,
    .z = 0.00000000000000000000E+000,
    .yaw = 0.00000000000000000000E+000
};
}
#endif

 
flag Trajectory_IsConstraintValid(const Trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->x, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->y, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->z, pErrCode);
	        if (ret) {
	            ret = MyReal_IsConstraintValid(&pVal->yaw, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag Trajectory_Equal(const Trajectory* pVal1, const Trajectory* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->x, &pVal2->x);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->y, &pVal2->y);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->z, &pVal2->z);
	        if (ret) {
	            ret = MyReal_Equal(&pVal1->yaw, &pVal2->yaw);
	        
	        }
	    }
	}

	return ret;
}

flag Trajectory_Encode(const Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = MyReal_Encode(&pVal->x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = MyReal_Encode(&pVal->y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = MyReal_Encode(&pVal->z, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode yaw */
	                ret = MyReal_Encode(&pVal->yaw, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag Trajectory_Decode(Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode x */
	ret = MyReal_Decode(&pVal->x, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode y */
	    ret = MyReal_Decode(&pVal->y, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode z */
	        ret = MyReal_Decode(&pVal->z, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode yaw */
	            ret = MyReal_Decode(&pVal->yaw, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

flag Trajectory_ACN_Encode(const Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode x */
	    ret = MyReal_ACN_Encode(&pVal->x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode y */
	        ret = MyReal_ACN_Encode(&pVal->y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode z */
	            ret = MyReal_ACN_Encode(&pVal->z, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode yaw */
	                ret = MyReal_ACN_Encode(&pVal->yaw, pBitStrm, pErrCode, FALSE);

	            }

	        }

	    }

    }

	return ret;
}

flag Trajectory_ACN_Decode(Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode x */
    ret = MyReal_ACN_Decode(&pVal->x, pBitStrm, pErrCode);
    if (ret) {
        /*Decode y */
        ret = MyReal_ACN_Decode(&pVal->y, pBitStrm, pErrCode);
        if (ret) {
            /*Decode z */
            ret = MyReal_ACN_Decode(&pVal->z, pBitStrm, pErrCode);
            if (ret) {
                /*Decode yaw */
                ret = MyReal_ACN_Decode(&pVal->yaw, pBitStrm, pErrCode);

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Velocity_Initialize(Velocity* pVal)
{
    *pVal = (Velocity) {
    .vX = 0.00000000000000000000E+000,
    .vY = 0.00000000000000000000E+000,
    .vZ = 0.00000000000000000000E+000
};
}
#endif

 
flag Velocity_IsConstraintValid(const Velocity* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->vX, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->vY, pErrCode);
	    if (ret) {
	        ret = MyReal_IsConstraintValid(&pVal->vZ, pErrCode);
	    
	    }
	}

	return ret;
}

flag Velocity_Equal(const Velocity* pVal1, const Velocity* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->vX, &pVal2->vX);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->vY, &pVal2->vY);
	    if (ret) {
	        ret = MyReal_Equal(&pVal1->vZ, &pVal2->vZ);
	    
	    }
	}

	return ret;
}

flag Velocity_Encode(const Velocity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Velocity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vX */
	    ret = MyReal_Encode(&pVal->vX, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode vY */
	        ret = MyReal_Encode(&pVal->vY, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode vZ */
	            ret = MyReal_Encode(&pVal->vZ, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag Velocity_Decode(Velocity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vX */
	ret = MyReal_Decode(&pVal->vX, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode vY */
	    ret = MyReal_Decode(&pVal->vY, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode vZ */
	        ret = MyReal_Decode(&pVal->vZ, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag Velocity_ACN_Encode(const Velocity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Velocity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vX */
	    ret = MyReal_ACN_Encode(&pVal->vX, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode vY */
	        ret = MyReal_ACN_Encode(&pVal->vY, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode vZ */
	            ret = MyReal_ACN_Encode(&pVal->vZ, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag Velocity_ACN_Decode(Velocity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode vX */
    ret = MyReal_ACN_Decode(&pVal->vX, pBitStrm, pErrCode);
    if (ret) {
        /*Decode vY */
        ret = MyReal_ACN_Decode(&pVal->vY, pBitStrm, pErrCode);
        if (ret) {
            /*Decode vZ */
            ret = MyReal_ACN_Decode(&pVal->vZ, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void HoverAction_Initialize(HoverAction* pVal)
{
    *pVal = (HoverAction) {
    .yaw_rate = 0.00000000000000000000E+000,
    .duration = 0.00000000000000000000E+000
};
}
#endif

 
flag HoverAction_IsConstraintValid(const HoverAction* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyReal_IsConstraintValid(&pVal->yaw_rate, pErrCode);
	if (ret) {
	    ret = MyReal_IsConstraintValid(&pVal->duration, pErrCode);
	
	}

	return ret;
}

flag HoverAction_Equal(const HoverAction* pVal1, const HoverAction* pVal2)
{
	flag ret=TRUE;
	
	ret = MyReal_Equal(&pVal1->yaw_rate, &pVal2->yaw_rate);
	if (ret) {
	    ret = MyReal_Equal(&pVal1->duration, &pVal2->duration);
	
	}

	return ret;
}

flag HoverAction_Encode(const HoverAction* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? HoverAction_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yaw_rate */
	    ret = MyReal_Encode(&pVal->yaw_rate, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode duration */
	        ret = MyReal_Encode(&pVal->duration, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag HoverAction_Decode(HoverAction* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode yaw_rate */
	ret = MyReal_Decode(&pVal->yaw_rate, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode duration */
	    ret = MyReal_Decode(&pVal->duration, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag HoverAction_ACN_Encode(const HoverAction* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? HoverAction_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode yaw_rate */
	    ret = MyReal_ACN_Encode(&pVal->yaw_rate, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode duration */
	        ret = MyReal_ACN_Encode(&pVal->duration, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag HoverAction_ACN_Decode(HoverAction* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode yaw_rate */
    ret = MyReal_ACN_Decode(&pVal->yaw_rate, pBitStrm, pErrCode);
    if (ret) {
        /*Decode duration */
        ret = MyReal_ACN_Decode(&pVal->duration, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ReferencePath_actions_Initialize(ReferencePath_actions* pVal)
{
    *pVal = (ReferencePath_actions) {    .arr = 
    {
        {
            .yaw_rate = 0.00000000000000000000E+000,
            .duration = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag ReferencePath_actions_IsConstraintValid(const ReferencePath_actions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 3)) {
	    ret = HoverAction_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag ReferencePath_actions_Equal(const ReferencePath_actions* pVal1, const ReferencePath_actions* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<3; i1++) 
	{
		ret = HoverAction_Equal(&pVal1->arr[i1], &pVal2->arr[i1]);
	}

	return ret;
}

flag ReferencePath_actions_Encode(const ReferencePath_actions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? ReferencePath_actions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = HoverAction_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferencePath_actions_Decode(ReferencePath_actions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = HoverAction_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag ReferencePath_actions_ACN_Encode(const ReferencePath_actions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? ReferencePath_actions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = HoverAction_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag ReferencePath_actions_ACN_Decode(ReferencePath_actions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)3) && ret; i1++) 
    {
    	ret = HoverAction_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void ReferencePath_Initialize(ReferencePath* pVal)
{
    *pVal = (ReferencePath) {
    .locations = {    .arr = 
        {
            {
                .x = 0.00000000000000000000E+000,
                .y = 0.00000000000000000000E+000,
                .z = 0.00000000000000000000E+000
            }        
        }
    },
    .actions = {    .arr = 
        {
            {
                .yaw_rate = 0.00000000000000000000E+000,
                .duration = 0.00000000000000000000E+000
            }        
        }
    }
};
}
#endif

 
flag ReferencePath_IsConstraintValid(const ReferencePath* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ReferencePath_locations_IsConstraintValid(&pVal->locations, pErrCode);
	if (ret) {
	    ret = ReferencePath_actions_IsConstraintValid(&pVal->actions, pErrCode);
	
	}

	return ret;
}

flag ReferencePath_Equal(const ReferencePath* pVal1, const ReferencePath* pVal2)
{
	flag ret=TRUE;
	
	ret = ReferencePath_locations_Equal(&pVal1->locations, &pVal2->locations);
	if (ret) {
	    ret = ReferencePath_actions_Equal(&pVal1->actions, &pVal2->actions);
	
	}

	return ret;
}

flag ReferencePath_Encode(const ReferencePath* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? ReferencePath_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode locations */
	    ret = ReferencePath_locations_Encode(&pVal->locations, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode actions */
	        ret = ReferencePath_actions_Encode(&pVal->actions, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag ReferencePath_Decode(ReferencePath* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode locations */
	ret = ReferencePath_locations_Decode(&pVal->locations, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode actions */
	    ret = ReferencePath_actions_Decode(&pVal->actions, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag ReferencePath_ACN_Encode(const ReferencePath* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? ReferencePath_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode locations */
	    ret = ReferencePath_locations_ACN_Encode(&pVal->locations, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode actions */
	        ret = ReferencePath_actions_ACN_Encode(&pVal->actions, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag ReferencePath_ACN_Decode(ReferencePath* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode locations */
    ret = ReferencePath_locations_ACN_Decode(&pVal->locations, pBitStrm, pErrCode);
    if (ret) {
        /*Decode actions */
        ret = ReferencePath_actions_ACN_Decode(&pVal->actions, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyBool_Initialize(MyBool* pVal)
{
    *pVal = (MyBool) FALSE;
}
#endif

 
flag MyBool_IsConstraintValid(const MyBool* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag MyBool_Equal(const MyBool* pVal1, const MyBool* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (*pVal1 && *pVal2) || (!*pVal1 && !*pVal2));

	return ret;
}

flag MyBool_Encode(const MyBool* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyBool_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag MyBool_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435469;

	return ret;
}

flag MyBool_ACN_Encode(const MyBool* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyBool_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag MyBool_ACN_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435470;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyEnum_Initialize(MyEnum* pVal)
{
    *pVal = (MyEnum) hello;
}
#endif

 
flag MyEnum_IsConstraintValid(const MyEnum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == hello) || (*pVal == world)) || (*pVal == howareyou));
	*pErrCode = ret ? 0 : ERR_MyEnum;

	return ret;
}

flag MyEnum_Equal(const MyEnum* pVal1, const MyEnum* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag MyEnum_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case hello:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case world:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case howareyou:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435471;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = hello;
	            break;
	        case 1: 
	            *pVal = world;
	            break;
	        case 2: 
	            *pVal = howareyou;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MyEnum_ACN_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case hello:
	            intVal = 0;
	            break;
	        case world:
	            intVal = 1;
	            break;
	        case howareyou:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741827;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag MyEnum_ACN_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 268435472;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = hello;
                break;
            case 1:
                *pVal = world;
                break;
            case 2:
                *pVal = howareyou;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741828;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeqOf_Initialize(MySeqOf* pVal)
{
    *pVal = (MySeqOf) {    .arr = 
    {
        hello        
    }
};
}
#endif

 
flag MySeqOf_IsConstraintValid(const MySeqOf* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 2)) {
	    ret = MyEnum_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag MySeqOf_Equal(const MySeqOf* pVal1, const MySeqOf* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<2; i1++) 
	{
		ret = MyEnum_Equal(&pVal1->arr[i1], &pVal2->arr[i1]);
	}

	return ret;
}

flag MySeqOf_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)2) && ret; i1++) 
	    {
	    	ret = MyEnum_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag MySeqOf_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)2) && ret; i1++) 
	{
		ret = MyEnum_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag MySeqOf_ACN_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)2) && ret; i1++) 
	    {
	    	ret = MyEnum_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag MySeqOf_ACN_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)2) && ret; i1++) 
    {
    	ret = MyEnum_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void UserCommand_Initialize(UserCommand* pVal)
{
    *pVal = (UserCommand) sysStart;
}
#endif

 
flag UserCommand_IsConstraintValid(const UserCommand* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == sysStart) || (*pVal == sysPause)) || (*pVal == sysStop));
	*pErrCode = ret ? 0 : ERR_UserCommand;

	return ret;
}

flag UserCommand_Equal(const UserCommand* pVal1, const UserCommand* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag UserCommand_Encode(const UserCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? UserCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case sysStart:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case sysPause:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case sysStop:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741829; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag UserCommand_Decode(UserCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435473;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = sysStart;
	            break;
	        case 1: 
	            *pVal = sysPause;
	            break;
	        case 2: 
	            *pVal = sysStop;
	            break;
	        default:
		        *pErrCode = 1073741830;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag UserCommand_ACN_Encode(const UserCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? UserCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case sysStart:
	            intVal = 0;
	            break;
	        case sysPause:
	            intVal = 1;
	            break;
	        case sysStop:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741831;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag UserCommand_ACN_Decode(UserCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 268435474;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = sysStart;
                break;
            case 1:
                *pVal = sysPause;
                break;
            case 2:
                *pVal = sysStop;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741832;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Color_Initialize(Color* pVal)
{
    *pVal = (Color) black;
}
#endif

 
flag Color_IsConstraintValid(const Color* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == black) || (*pVal == pink)) || (*pVal == red));
	*pErrCode = ret ? 0 : ERR_Color;

	return ret;
}

flag Color_Equal(const Color* pVal1, const Color* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag Color_Encode(const Color* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Color_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case black:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case pink:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case red:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741833; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag Color_Decode(Color* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435475;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = black;
	            break;
	        case 1: 
	            *pVal = pink;
	            break;
	        case 2: 
	            *pVal = red;
	            break;
	        default:
		        *pErrCode = 1073741834;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag Color_ACN_Encode(const Color* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? Color_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case black:
	            intVal = 0;
	            break;
	        case pink:
	            intVal = 1;
	            break;
	        case red:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741835;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag Color_ACN_Decode(Color* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 268435476;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = black;
                break;
            case 1:
                *pVal = pink;
                break;
            case 2:
                *pVal = red;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741836;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Agent_Initialize(Agent* pVal)
{
    *pVal = (Agent) {
    .agentID = -128,
    .agentColor = black,
    .currentPosition = {
        .x = 0.00000000000000000000E+000,
        .y = 0.00000000000000000000E+000,
        .z = 0.00000000000000000000E+000
    },
    .currentOrientation = {
        .roll = 0.00000000000000000000E+000,
        .pitch = 0.00000000000000000000E+000,
        .yaw = 0.00000000000000000000E+000
    },
    .currentVelocity = {
        .vX = 0.00000000000000000000E+000,
        .vY = 0.00000000000000000000E+000,
        .vZ = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag Agent_IsConstraintValid(const Agent* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_Int8_IsConstraintValid(&pVal->agentID, pErrCode);
	if (ret) {
	    ret = Color_IsConstraintValid(&pVal->agentColor, pErrCode);
	    if (ret) {
	        ret = Position_IsConstraintValid(&pVal->currentPosition, pErrCode);
	        if (ret) {
	            ret = Orientation_IsConstraintValid(&pVal->currentOrientation, pErrCode);
	            if (ret) {
	                ret = Velocity_IsConstraintValid(&pVal->currentVelocity, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag Agent_Equal(const Agent* pVal1, const Agent* pVal2)
{
	flag ret=TRUE;
	
	ret = T_Int8_Equal(&pVal1->agentID, &pVal2->agentID);
	if (ret) {
	    ret = Color_Equal(&pVal1->agentColor, &pVal2->agentColor);
	    if (ret) {
	        ret = Position_Equal(&pVal1->currentPosition, &pVal2->currentPosition);
	        if (ret) {
	            ret = Orientation_Equal(&pVal1->currentOrientation, &pVal2->currentOrientation);
	            if (ret) {
	                ret = Velocity_Equal(&pVal1->currentVelocity, &pVal2->currentVelocity);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag Agent_Encode(const Agent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Agent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode agentID */
	    ret = T_Int8_Encode(&pVal->agentID, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode agentColor */
	        ret = Color_Encode(&pVal->agentColor, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode currentPosition */
	            ret = Position_Encode(&pVal->currentPosition, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode currentOrientation */
	                ret = Orientation_Encode(&pVal->currentOrientation, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode currentVelocity */
	                    ret = Velocity_Encode(&pVal->currentVelocity, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag Agent_Decode(Agent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode agentID */
	ret = T_Int8_Decode(&pVal->agentID, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode agentColor */
	    ret = Color_Decode(&pVal->agentColor, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode currentPosition */
	        ret = Position_Decode(&pVal->currentPosition, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode currentOrientation */
	            ret = Orientation_Decode(&pVal->currentOrientation, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode currentVelocity */
	                ret = Velocity_Decode(&pVal->currentVelocity, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}

flag Agent_ACN_Encode(const Agent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? Agent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode agentID */
	    ret = T_Int8_ACN_Encode(&pVal->agentID, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode agentColor */
	        ret = Color_ACN_Encode(&pVal->agentColor, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode currentPosition */
	            ret = Position_ACN_Encode(&pVal->currentPosition, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode currentOrientation */
	                ret = Orientation_ACN_Encode(&pVal->currentOrientation, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode currentVelocity */
	                    ret = Velocity_ACN_Encode(&pVal->currentVelocity, pBitStrm, pErrCode, FALSE);

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag Agent_ACN_Decode(Agent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode agentID */
    ret = T_Int8_ACN_Decode(&pVal->agentID, pBitStrm, pErrCode);
    if (ret) {
        /*Decode agentColor */
        ret = Color_ACN_Decode(&pVal->agentColor, pBitStrm, pErrCode);
        if (ret) {
            /*Decode currentPosition */
            ret = Position_ACN_Decode(&pVal->currentPosition, pBitStrm, pErrCode);
            if (ret) {
                /*Decode currentOrientation */
                ret = Orientation_ACN_Decode(&pVal->currentOrientation, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode currentVelocity */
                    ret = Velocity_ACN_Decode(&pVal->currentVelocity, pBitStrm, pErrCode);

                }

            }

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void SystemState_Initialize(SystemState* pVal)
{
    *pVal = (SystemState) idle;
}
#endif

 
flag SystemState_IsConstraintValid(const SystemState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((((*pVal == idle) || (*pVal == initializing)) || (*pVal == runningOk)) || (*pVal == emergencyLand)) || (*pVal == safeReturn));
	*pErrCode = ret ? 0 : ERR_SystemState;

	return ret;
}

flag SystemState_Equal(const SystemState* pVal1, const SystemState* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag SystemState_Encode(const SystemState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SystemState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case idle:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case initializing:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case runningOk:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case emergencyLand:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case safeReturn:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:
	    	    *pErrCode = 1073741837; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag SystemState_Decode(SystemState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	*pErrCode = ret ? 0 : 268435477;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = idle;
	            break;
	        case 1: 
	            *pVal = initializing;
	            break;
	        case 2: 
	            *pVal = runningOk;
	            break;
	        case 3: 
	            *pVal = emergencyLand;
	            break;
	        case 4: 
	            *pVal = safeReturn;
	            break;
	        default:
		        *pErrCode = 1073741838;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag SystemState_ACN_Encode(const SystemState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? SystemState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case idle:
	            intVal = 0;
	            break;
	        case initializing:
	            intVal = 1;
	            break;
	        case runningOk:
	            intVal = 2;
	            break;
	        case emergencyLand:
	            intVal = 3;
	            break;
	        case safeReturn:
	            intVal = 4;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741839;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 4);
    }

	return ret;
}

flag SystemState_ACN_Decode(SystemState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 4);
    *pErrCode = ret ? 0 : 268435478;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = idle;
                break;
            case 1:
                *pVal = initializing;
                break;
            case 2:
                *pVal = runningOk;
                break;
            case 3:
                *pVal = emergencyLand;
                break;
            case 4:
                *pVal = safeReturn;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741840;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void FeedbackToGUI_Initialize(FeedbackToGUI* pVal)
{
    *pVal = (FeedbackToGUI) {
    .flight = {
        .rawASD = {
            .yawAct = 0.00000000000000000000E+000,
            .pitchAct = 0.00000000000000000000E+000,
            .rollAct = 0.00000000000000000000E+000,
            .baropAct = 0.00000000000000000000E+000,
            .accxAct = 0.00000000000000000000E+000,
            .accyAct = 0.00000000000000000000E+000,
            .acczAct = 0.00000000000000000000E+000
        }
    },
    .notification = idle
};
}
#endif

 
flag FeedbackToGUI_IsConstraintValid(const FeedbackToGUI* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = WorldData_IsConstraintValid(&pVal->flight, pErrCode);
	if (ret) {
	    ret = SystemState_IsConstraintValid(&pVal->notification, pErrCode);
	
	}

	return ret;
}

flag FeedbackToGUI_Equal(const FeedbackToGUI* pVal1, const FeedbackToGUI* pVal2)
{
	flag ret=TRUE;
	
	ret = WorldData_Equal(&pVal1->flight, &pVal2->flight);
	if (ret) {
	    ret = SystemState_Equal(&pVal1->notification, &pVal2->notification);
	
	}

	return ret;
}

flag FeedbackToGUI_Encode(const FeedbackToGUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? FeedbackToGUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode flight */
	    ret = WorldData_Encode(&pVal->flight, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode notification */
	        ret = SystemState_Encode(&pVal->notification, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag FeedbackToGUI_Decode(FeedbackToGUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode flight */
	ret = WorldData_Decode(&pVal->flight, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode notification */
	    ret = SystemState_Decode(&pVal->notification, pBitStrm, pErrCode);
	
	}


	return ret;
}

flag FeedbackToGUI_ACN_Encode(const FeedbackToGUI* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? FeedbackToGUI_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode flight */
	    ret = WorldData_ACN_Encode(&pVal->flight, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode notification */
	        ret = SystemState_ACN_Encode(&pVal->notification, pBitStrm, pErrCode, FALSE);

	    }

    }

	return ret;
}

flag FeedbackToGUI_ACN_Decode(FeedbackToGUI* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode flight */
    ret = WorldData_ACN_Decode(&pVal->flight, pBitStrm, pErrCode);
    if (ret) {
        /*Decode notification */
        ret = SystemState_ACN_Decode(&pVal->notification, pBitStrm, pErrCode);

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void SafetyEvent_Initialize(SafetyEvent* pVal)
{
    *pVal = (SafetyEvent) safe;
}
#endif

 
flag SafetyEvent_IsConstraintValid(const SafetyEvent* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == safe) || (*pVal == collision)) || (*pVal == wallColl)) || (*pVal == ceilColl));
	*pErrCode = ret ? 0 : ERR_SafetyEvent;

	return ret;
}

flag SafetyEvent_Equal(const SafetyEvent* pVal1, const SafetyEvent* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag SafetyEvent_Encode(const SafetyEvent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? SafetyEvent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case safe:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case collision:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case wallColl:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case ceilColl:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1073741841; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag SafetyEvent_Decode(SafetyEvent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435479;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = safe;
	            break;
	        case 1: 
	            *pVal = collision;
	            break;
	        case 2: 
	            *pVal = wallColl;
	            break;
	        case 3: 
	            *pVal = ceilColl;
	            break;
	        default:
		        *pErrCode = 1073741842;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag SafetyEvent_ACN_Encode(const SafetyEvent* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? SafetyEvent_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case safe:
	            intVal = 0;
	            break;
	        case collision:
	            intVal = 1;
	            break;
	        case wallColl:
	            intVal = 2;
	            break;
	        case ceilColl:
	            intVal = 3;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741843;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 3);
    }

	return ret;
}

flag SafetyEvent_ACN_Decode(SafetyEvent* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 3);
    *pErrCode = ret ? 0 : 268435480;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = safe;
                break;
            case 1:
                *pVal = collision;
                break;
            case 2:
                *pVal = wallColl;
                break;
            case 3:
                *pVal = ceilColl;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741844;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyOctStr_Initialize(MyOctStr* pVal)
{
    *pVal = (MyOctStr) {
    {
        0x00
    }
};
}
#endif

 
flag MyOctStr_IsConstraintValid(const MyOctStr* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (3 == 3);
	*pErrCode = ret ? 0 : ERR_MyOctStr;

	return ret;
}

flag MyOctStr_Equal(const MyOctStr* pVal1, const MyOctStr* pVal2)
{
	flag ret=TRUE;
	
	ret = (memcmp(pVal1->arr, pVal2->arr, 3) ==0);
		

	return ret;
}

flag MyOctStr_Encode(const MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? MyOctStr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag MyOctStr_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435481;
	}

	return ret;
}

flag MyOctStr_ACN_Encode(const MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? MyOctStr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag MyOctStr_ACN_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)3) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435482;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeq_validity_Initialize(MySeq_validity* pVal)
{
    *pVal = (MySeq_validity) valid;
}
#endif

 
flag MySeq_validity_IsConstraintValid(const MySeq_validity* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == valid) || (*pVal == invalid));
	*pErrCode = ret ? 0 : ERR_MySeq_validity;

	return ret;
}

flag MySeq_validity_Equal(const MySeq_validity* pVal1, const MySeq_validity* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag MySeq_validity_Encode(const MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1073741845; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MySeq_validity_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435483;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = valid;
	            break;
	        case 1: 
	            *pVal = invalid;
	            break;
	        default:
		        *pErrCode = 1073741846;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MySeq_validity_ACN_Encode(const MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? MySeq_validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case valid:
	            intVal = 0;
	            break;
	        case invalid:
	            intVal = 1;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741847;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
    }

	return ret;
}

flag MySeq_validity_ACN_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 1);
    *pErrCode = ret ? 0 : 268435484;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = valid;
                break;
            case 1:
                *pVal = invalid;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741848;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeq_Initialize(MySeq* pVal)
{
    *pVal = (MySeq) {
    .input_data = 0,
    .output_data = 0,
    .validity = valid
};
}
#endif

 
flag MySeq_IsConstraintValid(const MySeq* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyInteger_IsConstraintValid(&pVal->input_data, pErrCode);
	if (ret) {
	    ret = MyInteger_IsConstraintValid(&pVal->output_data, pErrCode);
	    if (ret) {
	        ret = MySeq_validity_IsConstraintValid(&pVal->validity, pErrCode);
	    
	    }
	}

	return ret;
}

flag MySeq_Equal(const MySeq* pVal1, const MySeq* pVal2)
{
	flag ret=TRUE;
	
	ret = MyInteger_Equal(&pVal1->input_data, &pVal2->input_data);
	if (ret) {
	    ret = MyInteger_Equal(&pVal1->output_data, &pVal2->output_data);
	    if (ret) {
	        ret = MySeq_validity_Equal(&pVal1->validity, &pVal2->validity);
	    
	    }
	}

	return ret;
}

flag MySeq_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode input_data */
	    ret = MyInteger_Encode(&pVal->input_data, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode output_data */
	        ret = MyInteger_Encode(&pVal->output_data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = MySeq_validity_Encode(&pVal->validity, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode input_data */
	ret = MyInteger_Decode(&pVal->input_data, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode output_data */
	    ret = MyInteger_Decode(&pVal->output_data, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = MySeq_validity_Decode(&pVal->validity, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag MySeq_ACN_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode input_data */
	    ret = MyInteger_ACN_Encode(&pVal->input_data, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode output_data */
	        ret = MyInteger_ACN_Encode(&pVal->output_data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = MySeq_validity_ACN_Encode(&pVal->validity, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode input_data */
    ret = MyInteger_ACN_Decode(&pVal->input_data, pBitStrm, pErrCode);
    if (ret) {
        /*Decode output_data */
        ret = MyInteger_ACN_Decode(&pVal->output_data, pBitStrm, pErrCode);
        if (ret) {
            /*Decode validity */
            ret = MySeq_validity_ACN_Decode(&pVal->validity, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyChoice_Initialize(MyChoice* pVal)
{
    *pVal = (MyChoice) {
    .kind = a_PRESENT,
    .u = { .a = FALSE}
};
}
#endif

 
flag MyChoice_IsConstraintValid(const MyChoice* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case a_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    case b_PRESENT :
	        ret = MySeq_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag MyChoice_Equal(const MyChoice* pVal1, const MyChoice* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case a_PRESENT:
			ret = ( (pVal1->u.a && pVal2->u.a) || (!pVal1->u.a && !pVal2->u.a));
			break;
		case b_PRESENT:
			ret = MySeq_Equal(&pVal1->u.b, &pVal2->u.b);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag MyChoice_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435485;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, &pVal->u.a);
	    	*pErrCode = ret ? 0 : 268435486;
	    	break;
	    case 1:
	    	pVal->kind = b_PRESENT;
	    	ret = MySeq_Decode(&pVal->u.b, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MyChoice_ACN_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	{
	    		static byte true_data[] = {0x80};
	    		static byte false_data[] = {0x7F};
	    	    byte* tmp = pVal->u.a ? true_data : false_data; 
	    	    BitStream_AppendBits(pBitStrm, tmp, 1);
	    	}
	    	break;
	    case b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_ACN_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306372;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyChoice_ACN_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
    *pErrCode = ret ? 0 : 268435487;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = a_PRESENT;
        	{
        		static byte tmp[] = {0x80};
        		ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->u.a);
        	    *pErrCode = ret ? 0 : 268435488;
        	}
        	break;
        case 1:
        	pVal->kind = b_PRESENT;
        	ret = MySeq_ACN_Decode(&pVal->u.b, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306373;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}

const MySeqOf myVar = {    .arr = 
    {
        hello,
        world        
    }
};
