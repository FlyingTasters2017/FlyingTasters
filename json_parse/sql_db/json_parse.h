#ifndef GENERATED_ASN1SCC_JSON_PARSE_H
#define GENERATED_ASN1SCC_JSON_PARSE_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif



typedef asn1SccSint T_Int32;

#define T_Int32_REQUIRED_BYTES_FOR_ENCODING       4 
#define T_Int32_REQUIRED_BITS_FOR_ENCODING        32
#define T_Int32_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define T_Int32_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define T_Int32_REQUIRED_BYTES_FOR_XER_ENCODING   39

void T_Int32_Initialize(T_Int32* pVal);
flag T_Int32_IsConstraintValid(const T_Int32* val, int* pErrCode);
flag T_Int32_Equal(const T_Int32* val1, const T_Int32* val2);

#ifndef ERR_T_Int32 
#define ERR_T_Int32		1001  /*(-2147483648 .. 2147483647)*/
#endif

typedef asn1SccUint T_UInt32;

#define T_UInt32_REQUIRED_BYTES_FOR_ENCODING       4 
#define T_UInt32_REQUIRED_BITS_FOR_ENCODING        32
#define T_UInt32_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define T_UInt32_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define T_UInt32_REQUIRED_BYTES_FOR_XER_ENCODING   41

void T_UInt32_Initialize(T_UInt32* pVal);
flag T_UInt32_IsConstraintValid(const T_UInt32* val, int* pErrCode);
flag T_UInt32_Equal(const T_UInt32* val1, const T_UInt32* val2);

#ifndef ERR_T_UInt32 
#define ERR_T_UInt32		1002  /*(0 .. 4294967295)*/
#endif

typedef asn1SccSint T_Int8;

#define T_Int8_REQUIRED_BYTES_FOR_ENCODING       1 
#define T_Int8_REQUIRED_BITS_FOR_ENCODING        8
#define T_Int8_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define T_Int8_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define T_Int8_REQUIRED_BYTES_FOR_XER_ENCODING   37

void T_Int8_Initialize(T_Int8* pVal);
flag T_Int8_IsConstraintValid(const T_Int8* val, int* pErrCode);
flag T_Int8_Equal(const T_Int8* val1, const T_Int8* val2);

#ifndef ERR_T_Int8 
#define ERR_T_Int8		1003  /*(-128 .. 127)*/
#endif

typedef asn1SccUint T_UInt8;

#define T_UInt8_REQUIRED_BYTES_FOR_ENCODING       1 
#define T_UInt8_REQUIRED_BITS_FOR_ENCODING        8
#define T_UInt8_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define T_UInt8_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define T_UInt8_REQUIRED_BYTES_FOR_XER_ENCODING   39

void T_UInt8_Initialize(T_UInt8* pVal);
flag T_UInt8_IsConstraintValid(const T_UInt8* val, int* pErrCode);
flag T_UInt8_Equal(const T_UInt8* val1, const T_UInt8* val2);

#ifndef ERR_T_UInt8 
#define ERR_T_UInt8		1004  /*(0 .. 255)*/
#endif

typedef T_UInt8 MyInteger;

#define MyInteger_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyInteger_REQUIRED_BITS_FOR_ENCODING        8
#define MyInteger_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyInteger_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define MyInteger_REQUIRED_BYTES_FOR_XER_ENCODING   43

void MyInteger_Initialize(MyInteger* pVal);
flag MyInteger_IsConstraintValid(const MyInteger* val, int* pErrCode);
flag MyInteger_Equal(const MyInteger* val1, const MyInteger* val2);



typedef flag T_Boolean;

#define T_Boolean_REQUIRED_BYTES_FOR_ENCODING       1 
#define T_Boolean_REQUIRED_BITS_FOR_ENCODING        1
#define T_Boolean_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define T_Boolean_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define T_Boolean_REQUIRED_BYTES_FOR_XER_ENCODING   36

void T_Boolean_Initialize(T_Boolean* pVal);
flag T_Boolean_IsConstraintValid(const T_Boolean* val, int* pErrCode);
flag T_Boolean_Equal(const T_Boolean* val1, const T_Boolean* val2);



typedef double MyReal;

#define MyReal_REQUIRED_BYTES_FOR_ENCODING       13 
#define MyReal_REQUIRED_BITS_FOR_ENCODING        104
#define MyReal_REQUIRED_BYTES_FOR_ACN_ENCODING   13 
#define MyReal_REQUIRED_BITS_FOR_ACN_ENCODING    104
#define MyReal_REQUIRED_BYTES_FOR_XER_ENCODING   67

void MyReal_Initialize(MyReal* pVal);
flag MyReal_IsConstraintValid(const MyReal* val, int* pErrCode);
flag MyReal_Equal(const MyReal* val1, const MyReal* val2);

#ifndef ERR_MyReal 
#define ERR_MyReal		1005  /*(0.00000000000000000000E+000 .. 1.00000000000000000000E+003)*/
#endif

typedef flag MyBool;

#define MyBool_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyBool_REQUIRED_BITS_FOR_ENCODING        1
#define MyBool_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyBool_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define MyBool_REQUIRED_BYTES_FOR_XER_ENCODING   30

void MyBool_Initialize(MyBool* pVal);
flag MyBool_IsConstraintValid(const MyBool* val, int* pErrCode);
flag MyBool_Equal(const MyBool* val1, const MyBool* val2);



typedef enum {
    hello = 0,
    world = 1,
    howareyou = 2
} MyEnum;

#define MyEnum_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyEnum_REQUIRED_BITS_FOR_ENCODING        2
#define MyEnum_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyEnum_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define MyEnum_REQUIRED_BYTES_FOR_XER_ENCODING   30

void MyEnum_Initialize(MyEnum* pVal);
flag MyEnum_IsConstraintValid(const MyEnum* val, int* pErrCode);
flag MyEnum_Equal(const MyEnum* val1, const MyEnum* val2);

#ifndef ERR_MyEnum_unknown_enumeration_value 
#define ERR_MyEnum_unknown_enumeration_value		1007  /**/
#endif
#ifndef ERR_MyEnum 
#define ERR_MyEnum		1006  /**/
#endif

typedef struct {    
    MyEnum arr[2];
} MySeqOf;

#define MySeqOf_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySeqOf_REQUIRED_BITS_FOR_ENCODING        4
#define MySeqOf_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySeqOf_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define MySeqOf_REQUIRED_BYTES_FOR_XER_ENCODING   55

void MySeqOf_Initialize(MySeqOf* pVal);
flag MySeqOf_IsConstraintValid(const MySeqOf* val, int* pErrCode);
flag MySeqOf_Equal(const MySeqOf* val1, const MySeqOf* val2);

#ifndef ERR_MySeqOf 
#define ERR_MySeqOf		1008  /*(SIZE(2))*/
#endif

typedef struct {    
    byte arr[3];
} MyOctStr;

#define MyOctStr_REQUIRED_BYTES_FOR_ENCODING       3 
#define MyOctStr_REQUIRED_BITS_FOR_ENCODING        24
#define MyOctStr_REQUIRED_BYTES_FOR_ACN_ENCODING   3 
#define MyOctStr_REQUIRED_BITS_FOR_ACN_ENCODING    24
#define MyOctStr_REQUIRED_BYTES_FOR_XER_ENCODING   27

void MyOctStr_Initialize(MyOctStr* pVal);
flag MyOctStr_IsConstraintValid(const MyOctStr* val, int* pErrCode);
flag MyOctStr_Equal(const MyOctStr* val1, const MyOctStr* val2);

#ifndef ERR_MyOctStr 
#define ERR_MyOctStr		1009  /*(SIZE(3))*/
#endif

typedef enum {
    valid = 0,
    invalid = 1
} MySeq_validity;

#define MySeq_validity_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySeq_validity_REQUIRED_BITS_FOR_ENCODING        1
#define MySeq_validity_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySeq_validity_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define MySeq_validity_REQUIRED_BYTES_FOR_XER_ENCODING   46

void MySeq_validity_Initialize(MySeq_validity* pVal);
flag MySeq_validity_IsConstraintValid(const MySeq_validity* val, int* pErrCode);
flag MySeq_validity_Equal(const MySeq_validity* val1, const MySeq_validity* val2);

#ifndef ERR_MySeq_validity_unknown_enumeration_value 
#define ERR_MySeq_validity_unknown_enumeration_value		1011  /**/
#endif
#ifndef ERR_MySeq_validity 
#define ERR_MySeq_validity		1010  /**/
#endif

typedef struct {
    MyInteger input_data;
    MyInteger output_data;
    MySeq_validity validity;
} MySeq;

#define MySeq_REQUIRED_BYTES_FOR_ENCODING       3 
#define MySeq_REQUIRED_BITS_FOR_ENCODING        17
#define MySeq_REQUIRED_BYTES_FOR_ACN_ENCODING   3 
#define MySeq_REQUIRED_BITS_FOR_ACN_ENCODING    17
#define MySeq_REQUIRED_BYTES_FOR_XER_ENCODING   141

void MySeq_Initialize(MySeq* pVal);
flag MySeq_IsConstraintValid(const MySeq* val, int* pErrCode);
flag MySeq_Equal(const MySeq* val1, const MySeq* val2);



typedef struct {
    enum {
        MyChoice_NONE,
        a_PRESENT,
        b_PRESENT 
    } kind;
    union {
        flag a;
        MySeq b;
    } u; 
} MyChoice;

#define MyChoice_REQUIRED_BYTES_FOR_ENCODING       3 
#define MyChoice_REQUIRED_BITS_FOR_ENCODING        19
#define MyChoice_REQUIRED_BYTES_FOR_ACN_ENCODING   3 
#define MyChoice_REQUIRED_BITS_FOR_ACN_ENCODING    19
#define MyChoice_REQUIRED_BYTES_FOR_XER_ENCODING   154

void MyChoice_Initialize(MyChoice* pVal);
flag MyChoice_IsConstraintValid(const MyChoice* val, int* pErrCode);
flag MyChoice_Equal(const MyChoice* val1, const MyChoice* val2);

#ifndef ERR_MyChoice_unknown_choice_index 
#define ERR_MyChoice_unknown_choice_index		1012  /**/
#endif

extern const MySeqOf myVar; 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

flag T_Int32_Encode(const T_Int32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_Int32_ACN_Encode(const T_Int32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_UInt32_Encode(const T_UInt32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_UInt32_ACN_Encode(const T_UInt32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_Int8_Encode(const T_Int8* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_Int8_ACN_Encode(const T_Int8* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_UInt8_Encode(const T_UInt8* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_UInt8_ACN_Encode(const T_UInt8* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyInteger_Encode(const MyInteger* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyInteger_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyInteger_ACN_Encode(const MyInteger* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyInteger_ACN_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_Boolean_Encode(const T_Boolean* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_Boolean_ACN_Encode(const T_Boolean* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyReal_Encode(const MyReal* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyReal_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyReal_ACN_Encode(const MyReal* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyReal_ACN_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyBool_Encode(const MyBool* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyBool_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyBool_ACN_Encode(const MyBool* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyBool_ACN_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyEnum_Encode(const MyEnum* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyEnum_ACN_Encode(const MyEnum* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyEnum_ACN_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_Encode(const MySeqOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_ACN_Encode(const MySeqOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_ACN_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyOctStr_Encode(const MyOctStr* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyOctStr_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyOctStr_ACN_Encode(const MyOctStr* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyOctStr_ACN_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_validity_Encode(const MySeq_validity* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_validity_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_validity_ACN_Encode(const MySeq_validity* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_validity_ACN_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_Encode(const MySeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_ACN_Encode(const MySeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_Encode(const MyChoice* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_ACN_Encode(const MyChoice* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_ACN_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode); 


#ifdef  __cplusplus
}
#define ENUM_hello	hello
#define ENUM_world	world
#define ENUM_howareyou	howareyou
#define ENUM_valid	valid
#define ENUM_invalid	invalid
#define CHOICE_a_PRESENT	MyChoice::a_PRESENT
#define CHOICE_b_PRESENT	MyChoice::b_PRESENT

#endif

#endif
