/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Int32_Initialize(T_Int32* pVal)
{
    *pVal = (T_Int32) -2147483648LL;
}
#endif

 
flag T_Int32_IsConstraintValid(const T_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_T_Int32;

	return ret;
}

flag T_Int32_Equal(const T_Int32* pVal1, const T_Int32* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_Int32_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag T_Int32_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : 268435457;

	return ret;
}

flag T_Int32_ACN_Encode(const T_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -2147483648LL, 2147483647LL);
    }

	return ret;
}

flag T_Int32_ACN_Decode(T_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
    *pErrCode = ret ? 0 : 268435458;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_UInt32_Initialize(T_UInt32* pVal)
{
    *pVal = (T_UInt32) 0;
}
#endif

 
flag T_UInt32_IsConstraintValid(const T_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_T_UInt32;

	return ret;
}

flag T_UInt32_Equal(const T_UInt32* pVal1, const T_UInt32* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_UInt32_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}

flag T_UInt32_ACN_Encode(const T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 4294967295LL);
    }

	return ret;
}

flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
    *pErrCode = ret ? 0 : 268435460;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Int8_Initialize(T_Int8* pVal)
{
    *pVal = (T_Int8) -128;
}
#endif

 
flag T_Int8_IsConstraintValid(const T_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_T_Int8;

	return ret;
}

flag T_Int8_Equal(const T_Int8* pVal1, const T_Int8* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_Int8_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag T_Int8_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : 268435461;

	return ret;
}

flag T_Int8_ACN_Encode(const T_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, -128, 127);
    }

	return ret;
}

flag T_Int8_ACN_Decode(T_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
    *pErrCode = ret ? 0 : 268435462;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_UInt8_Initialize(T_UInt8* pVal)
{
    *pVal = (T_UInt8) 0;
}
#endif

 
flag T_UInt8_IsConstraintValid(const T_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_T_UInt8;

	return ret;
}

flag T_UInt8_Equal(const T_UInt8* pVal1, const T_UInt8* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag T_UInt8_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag T_UInt8_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : 268435463;

	return ret;
}

flag T_UInt8_ACN_Encode(const T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag T_UInt8_ACN_Decode(T_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : 268435464;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyInteger_Initialize(MyInteger* pVal)
{
    *pVal = (MyInteger) 0;
}
#endif

 
flag MyInteger_IsConstraintValid(const MyInteger* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_UInt8_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag MyInteger_Equal(const MyInteger* pVal1, const MyInteger* pVal2)
{
	flag ret=TRUE;
	
	ret = T_UInt8_Equal(pVal1, pVal2);

	return ret;
}

flag MyInteger_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt8_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag MyInteger_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_UInt8_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

flag MyInteger_ACN_Encode(const MyInteger* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyInteger_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt8_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag MyInteger_ACN_Decode(MyInteger* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = T_UInt8_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void T_Boolean_Initialize(T_Boolean* pVal)
{
    *pVal = (T_Boolean) FALSE;
}
#endif

 
flag T_Boolean_IsConstraintValid(const T_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag T_Boolean_Equal(const T_Boolean* pVal1, const T_Boolean* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (*pVal1 && *pVal2) || (!*pVal1 && !*pVal2));

	return ret;
}

flag T_Boolean_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag T_Boolean_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435465;

	return ret;
}

flag T_Boolean_ACN_Encode(const T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? T_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag T_Boolean_ACN_Decode(T_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435466;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyReal_Initialize(MyReal* pVal)
{
    *pVal = (MyReal) 0.00000000000000000000E+000;
}
#endif

 
flag MyReal_IsConstraintValid(const MyReal* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0.00000000000000000000E+000 <= *pVal && *pVal <= 1.00000000000000000000E+003);
	*pErrCode = ret ? 0 : ERR_MyReal;

	return ret;
}

flag MyReal_Equal(const MyReal* pVal1, const MyReal* pVal2)
{
	flag ret=TRUE;
	
	ret =  *pVal1 == *pVal2 ? TRUE : (*pVal1 == 0.0 ? *pVal2 ==0.0 : (fabs((*pVal1 - *pVal2) / *pVal1) < 0.00001));

	return ret;
}

flag MyReal_Encode(const MyReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, *pVal);
    }

	return ret;
}

flag MyReal_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435467;

	return ret;
}

flag MyReal_ACN_Encode(const MyReal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyReal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, *pVal);
    }

	return ret;
}

flag MyReal_ACN_Decode(MyReal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    BitStream_DecodeReal(pBitStrm, pVal);
    *pErrCode = ret ? 0 : 268435468;
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyBool_Initialize(MyBool* pVal)
{
    *pVal = (MyBool) FALSE;
}
#endif

 
flag MyBool_IsConstraintValid(const MyBool* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag MyBool_Equal(const MyBool* pVal1, const MyBool* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (*pVal1 && *pVal2) || (!*pVal1 && !*pVal2));

	return ret;
}

flag MyBool_Encode(const MyBool* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyBool_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBit(pBitStrm,*pVal);
    }

	return ret;
}

flag MyBool_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : 268435469;

	return ret;
}

flag MyBool_ACN_Encode(const MyBool* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyBool_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = *pVal ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
    }

	return ret;
}

flag MyBool_ACN_Decode(MyBool* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, pVal);
        *pErrCode = ret ? 0 : 268435470;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyEnum_Initialize(MyEnum* pVal)
{
    *pVal = (MyEnum) hello;
}
#endif

 
flag MyEnum_IsConstraintValid(const MyEnum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == hello) || (*pVal == world)) || (*pVal == howareyou));
	*pErrCode = ret ? 0 : ERR_MyEnum;

	return ret;
}

flag MyEnum_Equal(const MyEnum* pVal1, const MyEnum* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag MyEnum_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case hello:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case world:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case howareyou:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435471;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = hello;
	            break;
	        case 1: 
	            *pVal = world;
	            break;
	        case 2: 
	            *pVal = howareyou;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MyEnum_ACN_Encode(const MyEnum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? MyEnum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case hello:
	            intVal = 0;
	            break;
	        case world:
	            intVal = 1;
	            break;
	        case howareyou:
	            intVal = 2;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741827;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 2);
    }

	return ret;
}

flag MyEnum_ACN_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 2);
    *pErrCode = ret ? 0 : 268435472;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = hello;
                break;
            case 1:
                *pVal = world;
                break;
            case 2:
                *pVal = howareyou;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741828;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeqOf_Initialize(MySeqOf* pVal)
{
    *pVal = (MySeqOf) {    .arr = 
    {
        hello        
    }
};
}
#endif

 
flag MySeqOf_IsConstraintValid(const MySeqOf* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	i1 = 0;
	while (ret && (i1< 2)) {
	    ret = MyEnum_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag MySeqOf_Equal(const MySeqOf* pVal1, const MySeqOf* pVal2)
{
	flag ret=TRUE;
	int i1=0;
	
	for(i1 = 0; ret && i1<2; i1++) 
	{
		ret = MyEnum_Equal(&pVal1->arr[i1], &pVal2->arr[i1]);
	}

	return ret;
}

flag MySeqOf_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)2) && ret; i1++) 
	    {
	    	ret = MyEnum_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag MySeqOf_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)2) && ret; i1++) 
	{
		ret = MyEnum_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}

flag MySeqOf_ACN_Encode(const MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? MySeqOf_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)2) && ret; i1++) 
	    {
	    	ret = MyEnum_ACN_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag MySeqOf_ACN_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)2) && ret; i1++) 
    {
    	ret = MyEnum_ACN_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyOctStr_Initialize(MyOctStr* pVal)
{
    *pVal = (MyOctStr) {
    {
        0x00
    }
};
}
#endif

 
flag MyOctStr_IsConstraintValid(const MyOctStr* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (3 == 3);
	*pErrCode = ret ? 0 : ERR_MyOctStr;

	return ret;
}

flag MyOctStr_Equal(const MyOctStr* pVal1, const MyOctStr* pVal2)
{
	flag ret=TRUE;
	
	ret = (memcmp(pVal1->arr, pVal2->arr, 3) ==0);
		

	return ret;
}

flag MyOctStr_Encode(const MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? MyOctStr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag MyOctStr_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1=0;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435473;
	}

	return ret;
}

flag MyOctStr_ACN_Encode(const MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? MyOctStr_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag MyOctStr_ACN_Decode(MyOctStr* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    	
    for(i1=0; (i1 < (int)3) && ret; i1++) 
    {
    	ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
    	*pErrCode = ret ? 0 : 268435474;
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeq_validity_Initialize(MySeq_validity* pVal)
{
    *pVal = (MySeq_validity) valid;
}
#endif

 
flag MySeq_validity_IsConstraintValid(const MySeq_validity* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == valid) || (*pVal == invalid));
	*pErrCode = ret ? 0 : ERR_MySeq_validity;

	return ret;
}

flag MySeq_validity_Equal(const MySeq_validity* pVal1, const MySeq_validity* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag MySeq_validity_Encode(const MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1073741829; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MySeq_validity_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435475;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = valid;
	            break;
	        case 1: 
	            *pVal = invalid;
	            break;
	        default:
		        *pErrCode = 1073741830;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MySeq_validity_ACN_Encode(const MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;

    ret = bCheckConstraints ? MySeq_validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case valid:
	            intVal = 0;
	            break;
	        case invalid:
	            intVal = 1;
	            break;
	        default:
	            ret = FALSE;                            //COVERAGE_IGNORE
	            *pErrCode = 1073741831;      //COVERAGE_IGNORE
	    }
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, intVal, 0, 1);
    }

	return ret;
}

flag MySeq_validity_ACN_Decode(MySeq_validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccUint intVal = 0;
    ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, &intVal, 0, 1);
    *pErrCode = ret ? 0 : 268435476;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = valid;
                break;
            case 1:
                *pVal = invalid;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = 1073741832;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MySeq_Initialize(MySeq* pVal)
{
    *pVal = (MySeq) {
    .input_data = 0,
    .output_data = 0,
    .validity = valid
};
}
#endif

 
flag MySeq_IsConstraintValid(const MySeq* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MyInteger_IsConstraintValid(&pVal->input_data, pErrCode);
	if (ret) {
	    ret = MyInteger_IsConstraintValid(&pVal->output_data, pErrCode);
	    if (ret) {
	        ret = MySeq_validity_IsConstraintValid(&pVal->validity, pErrCode);
	    
	    }
	}

	return ret;
}

flag MySeq_Equal(const MySeq* pVal1, const MySeq* pVal2)
{
	flag ret=TRUE;
	
	ret = MyInteger_Equal(&pVal1->input_data, &pVal2->input_data);
	if (ret) {
	    ret = MyInteger_Equal(&pVal1->output_data, &pVal2->output_data);
	    if (ret) {
	        ret = MySeq_validity_Equal(&pVal1->validity, &pVal2->validity);
	    
	    }
	}

	return ret;
}

flag MySeq_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode input_data */
	    ret = MyInteger_Encode(&pVal->input_data, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode output_data */
	        ret = MyInteger_Encode(&pVal->output_data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = MySeq_validity_Encode(&pVal->validity, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode input_data */
	ret = MyInteger_Decode(&pVal->input_data, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode output_data */
	    ret = MyInteger_Decode(&pVal->output_data, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode validity */
	        ret = MySeq_validity_Decode(&pVal->validity, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}

flag MySeq_ACN_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode input_data */
	    ret = MyInteger_ACN_Encode(&pVal->input_data, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode output_data */
	        ret = MyInteger_ACN_Encode(&pVal->output_data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode validity */
	            ret = MySeq_validity_ACN_Encode(&pVal->validity, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0;
    /*Decode input_data */
    ret = MyInteger_ACN_Decode(&pVal->input_data, pBitStrm, pErrCode);
    if (ret) {
        /*Decode output_data */
        ret = MyInteger_ACN_Decode(&pVal->output_data, pBitStrm, pErrCode);
        if (ret) {
            /*Decode validity */
            ret = MySeq_validity_ACN_Decode(&pVal->validity, pBitStrm, pErrCode);

        }

    }


    return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void MyChoice_Initialize(MyChoice* pVal)
{
    *pVal = (MyChoice) {
    .kind = a_PRESENT,
    .u = { .a = FALSE}
};
}
#endif

 
flag MyChoice_IsConstraintValid(const MyChoice* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case a_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    case b_PRESENT :
	        ret = MySeq_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag MyChoice_Equal(const MyChoice* pVal1, const MyChoice* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case a_PRESENT:
			ret = ( (pVal1->u.a && pVal2->u.a) || (!pVal1->u.a && !pVal2->u.a));
			break;
		case b_PRESENT:
			ret = MySeq_Equal(&pVal1->u.b, &pVal2->u.b);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag MyChoice_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	BitStream_AppendBit(pBitStrm,pVal->u.a);
	    	break;
	    case b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435477;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = a_PRESENT;
	    	ret = BitStream_ReadBit(pBitStrm, &pVal->u.a);
	    	*pErrCode = ret ? 0 : 268435478;
	    	break;
	    case 1:
	    	pVal->kind = b_PRESENT;
	    	ret = MySeq_Decode(&pVal->u.b, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

flag MyChoice_ACN_Encode(const MyChoice* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyChoice_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case a_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	{
	    		static byte true_data[] = {0x80};
	    		static byte false_data[] = {0x7F};
	    	    byte* tmp = pVal->u.a ? true_data : false_data; 
	    	    BitStream_AppendBits(pBitStrm, tmp, 1);
	    	}
	    	break;
	    case b_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = MySeq_ACN_Encode(&pVal->u.b, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306372;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MyChoice_ACN_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint nChoiceIndex;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
    *pErrCode = ret ? 0 : 268435479;
    if (ret) {
        switch(nChoiceIndex) 
        {
        case 0:
        	pVal->kind = a_PRESENT;
        	{
        		static byte tmp[] = {0x80};
        		ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->u.a);
        	    *pErrCode = ret ? 0 : 268435480;
        	}
        	break;
        case 1:
        	pVal->kind = b_PRESENT;
        	ret = MySeq_ACN_Decode(&pVal->u.b, pBitStrm, pErrCode);
        	break;
        default:
            *pErrCode = 805306373;     //COVERAGE_IGNORE
            ret = FALSE;                //COVERAGE_IGNORE
        }
    }
    return ret;
}

const MySeqOf myVar = {    .arr = 
    {
        hello,
        world        
    }
};
