-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH TASTE_BasicTypes;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview IS

MINUS_minus_1_00000000000000000000E_plus_003:CONSTANT adaasn1rtl.Asn1Real := -1.00000000000000000000E+003;

SUBTYPE MyChoice_a_pattern_array_range is Natural range 1..1;
SUBTYPE MyChoice_a_pattern_array is adaasn1rtl.BitArray(MyChoice_a_pattern_array_range);
MyChoice_a_pattern:CONSTANT MyChoice_a_pattern_array := MyChoice_a_pattern_array'(
                                                                                  1=>1);

SUBTYPE MyBool_pattern_array_range is Natural range 1..1;
SUBTYPE MyBool_pattern_array is adaasn1rtl.BitArray(MyBool_pattern_array_range);
MyBool_pattern:CONSTANT MyBool_pattern_array := MyBool_pattern_array'(1=>1);

FUNCTION asn1SccMyInteger_Init return asn1SccMyInteger
IS 
BEGIN
    RETURN 0;
END asn1SccMyInteger_Init;

FUNCTION asn1SccMyInteger_IsConstraintValid(val : in asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- TASTE-BasicTypes.T-UInt8-------
-- TASTE-BasicTypes.T-UInt8


    ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val);
    RETURN ret;
END asn1SccMyInteger_IsConstraintValid;

function asn1SccMyInteger_Equal(val1, val2: in asn1SccMyInteger) return Boolean
is
begin
    return TASTE_BasicTypes.asn1SccT_UInt8_Equal(val1, val2);
end asn1SccMyInteger_Equal;

FUNCTION asn1SccMyReal_Init return asn1SccMyReal
IS 
BEGIN
    RETURN 0.00000000000000000000E+000;
END asn1SccMyReal_Init;

FUNCTION asn1SccMyReal_IsConstraintValid(val : in asn1SccMyReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- REAL (-1.00000000000000000000E+003 .. 1.00000000000000000000E+003)-------
-- REAL (-1.00000000000000000000E+003 .. 1.00000000000000000000E+003)


    ret := adaasn1rtl.ASN1_RESULT'(Success => (MINUS_minus_1_00000000000000000000E_plus_003 <= val AND val <= 1.00000000000000000000E+003), ErrorCode => ERR_asn1SccMyReal);
    RETURN ret;
END asn1SccMyReal_IsConstraintValid;

function asn1SccMyReal_Equal(val1, val2: in asn1SccMyReal) return Boolean
is
begin
    return Asn1Real_Equal(val1, val2);
end asn1SccMyReal_Equal;

FUNCTION asn1SccMyBool_Init return asn1SccMyBool
IS 
BEGIN
    RETURN FALSE;
END asn1SccMyBool_Init;

function asn1SccMyBool_Equal(val1, val2: in asn1SccMyBool) return Boolean
is
begin
    return val1 = val2;
end asn1SccMyBool_Equal;

FUNCTION asn1SccMyEnum_Init return asn1SccMyEnum
IS 
BEGIN
    RETURN asn1Scchello;
END asn1SccMyEnum_Init;

FUNCTION asn1SccMyEnum_IsConstraintValid(val : in asn1SccMyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- ENUMERATED {
--     hello(0),
--     world(1),
--     howareyou(2)
-- } -------
-- ENUMERATED {
--     hello(0),
--     world(1),
--     howareyou(2)
-- } 


    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = asn1Scchello) OR (val = asn1Sccworld)) OR (val = asn1Scchowareyou)), ErrorCode => ERR_asn1SccMyEnum);
    RETURN ret;
END asn1SccMyEnum_IsConstraintValid;

function asn1SccMyEnum_Equal(val1, val2: in asn1SccMyEnum) return Boolean
is
begin
    return val1 = val2;
end asn1SccMyEnum_Equal;

FUNCTION asn1SccMySeqOf_Init return asn1SccMySeqOf
IS 
BEGIN
    RETURN asn1SccMySeqOf'(Data => asn1SccMySeqOf_array'( others => asn1Scchello));
END asn1SccMySeqOf_Init;

FUNCTION asn1SccMySeqOf_IsConstraintValid(val : in asn1SccMySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
    I1:Integer; 
 
BEGIN
-- SEQUENCE (SIZE(2)) OF MyEnum-------
-- SEQUENCE (SIZE(2)) OF MyEnum


    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
    I1 := 1;
    WHILE ret.Success AND I1<=2 LOOP
    --# assert I1 >= 1 AND I1 <= 2;
        ret := asn1SccMyEnum_IsConstraintValid(val.Data(I1));
        I1 := I1+1;
    END LOOP;
    RETURN ret;
END asn1SccMySeqOf_IsConstraintValid;

function asn1SccMySeqOf_Equal(val1, val2: in asn1SccMySeqOf) return Boolean
is
begin
    return (for all I in val1.Data'Range => asn1SccMyEnum_Equal(val1.Data(I), val2.Data(I)));	
end asn1SccMySeqOf_Equal;

FUNCTION asn1SccMyOctStr_Init return asn1SccMyOctStr
IS 
BEGIN
    RETURN asn1SccMyOctStr'(Data => asn1SccMyOctStr_array'(1=>16#00#, 2=>16#00#, 3=>16#00#, others=> 16#0#)) ;
END asn1SccMyOctStr_Init;

function asn1SccMyOctStr_Equal(val1, val2: in asn1SccMyOctStr) return Boolean
is
begin
    return val1.Data(val1.Data'Range) = val2.Data(val2.Data'Range);	
end asn1SccMyOctStr_Equal;

FUNCTION asn1SccMySeq_validity_Init return asn1SccMySeq_validity
IS 
BEGIN
    RETURN asn1Sccvalid;
END asn1SccMySeq_validity_Init;

FUNCTION asn1SccMySeq_validity_IsConstraintValid(val : in asn1SccMySeq_validity) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- ENUMERATED {
--     valid(0),
--     invalid(1)
-- } -------
-- ENUMERATED {
--     valid(0),
--     invalid(1)
-- } 


    ret := adaasn1rtl.ASN1_RESULT'(Success => ((val = asn1Sccvalid) OR (val = asn1Sccinvalid)), ErrorCode => ERR_asn1SccMySeq_validity);
    RETURN ret;
END asn1SccMySeq_validity_IsConstraintValid;

function asn1SccMySeq_validity_Equal(val1, val2: in asn1SccMySeq_validity) return Boolean
is
begin
    return val1 = val2;
end asn1SccMySeq_validity_Equal;

FUNCTION asn1SccMySeq_Init return asn1SccMySeq
IS 
BEGIN
    RETURN asn1SccMySeq'(
    input_data => 0,
    output_data => 0,
    validity => asn1Sccvalid
    );
END asn1SccMySeq_Init;

FUNCTION asn1SccMySeq_IsConstraintValid(val : in asn1SccMySeq) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- SEQUENCE {
--     input-data      MyInteger ,
--     output-data     MyInteger ,
--     validity        MySeq-validity 
-- } -------
-- SEQUENCE {
--     input-data      MyInteger ,
--     output-data     MyInteger ,
--     validity        MySeq-validity 
-- } 


    ret := asn1SccMyInteger_IsConstraintValid(val.input_data);
    IF ret.Success THEN
        ret := asn1SccMyInteger_IsConstraintValid(val.output_data);
        IF ret.Success THEN
            ret := asn1SccMySeq_validity_IsConstraintValid(val.validity);
            IF ret.Success THEN
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
            END IF;
        END IF;
    END IF;
    RETURN ret;
END asn1SccMySeq_IsConstraintValid;

function asn1SccMySeq_Equal(val1, val2: in asn1SccMySeq) return Boolean
is
begin
    return asn1SccMyInteger_Equal(val1.input_data, val2.input_data) and asn1SccMyInteger_Equal(val1.output_data, val2.output_data) and asn1SccMySeq_validity_Equal(val1.validity, val2.validity);
end asn1SccMySeq_Equal;

FUNCTION asn1SccMyChoice_kind(val:asn1SccMyChoice) RETURN asn1SccMyChoice_selection 
IS --# hide asn1SccMyChoice_kind;
BEGIN
    return val.kind;
END asn1SccMyChoice_kind;

FUNCTION asn1SccMyChoice_a_get(val:asn1SccMyChoice) RETURN adaasn1rtl.Asn1Boolean
IS --# hide asn1SccMyChoice_a_get;
BEGIN
    RETURN val.a;
END asn1SccMyChoice_a_get;

FUNCTION asn1SccMyChoice_a_set(itm:adaasn1rtl.Asn1Boolean) RETURN asn1SccMyChoice
IS --# hide asn1SccMyChoice_a_set;
BEGIN
    RETURN asn1SccMyChoice'(kind => a_PRESENT, a => itm);
END asn1SccMyChoice_a_set;
FUNCTION asn1SccMyChoice_b_get(val:asn1SccMyChoice) RETURN asn1SccMySeq
IS --# hide asn1SccMyChoice_b_get;
BEGIN
    RETURN val.b;
END asn1SccMyChoice_b_get;

FUNCTION asn1SccMyChoice_b_set(itm:asn1SccMySeq) RETURN asn1SccMyChoice
IS --# hide asn1SccMyChoice_b_set;
BEGIN
    RETURN asn1SccMyChoice'(kind => b_PRESENT, b => itm);
END asn1SccMyChoice_b_set;

FUNCTION asn1SccMyChoice_Init return asn1SccMyChoice
IS --#hide asn1SccMyChoice_Init;
BEGIN
    RETURN asn1SccMyChoice_a_set(FALSE);
END asn1SccMyChoice_Init;

FUNCTION asn1SccMyChoice_IsConstraintValid(val : in asn1SccMyChoice) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- CHOICE {
--     a               BOOLEAN ,
--     b               MySeq
-- } -------
-- CHOICE {
--     a               BOOLEAN ,
--     b               MySeq
-- } 


    CASE asn1SccMyChoice_kind(val) IS
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
        WHEN b_PRESENT =>
            ret := asn1SccMySeq_IsConstraintValid(asn1SccMyChoice_b_get(val));
    END CASE;
    RETURN ret;
END asn1SccMyChoice_IsConstraintValid;

function asn1SccMyChoice_Equal(val1, val2: in asn1SccMyChoice) return Boolean
is
begin
    return asn1SccMyChoice_kind(val1) = asn1SccMyChoice_kind(val2) and then
    ((if asn1SccMyChoice_kind(val1) = a_PRESENT then
 Asn1Boolean_Equal(asn1SccMyChoice_a_get(val1), asn1SccMyChoice_a_get(val2)) else False) or 
(if asn1SccMyChoice_kind(val1) = b_PRESENT then
 asn1SccMySeq_Equal(asn1SccMyChoice_b_get(val1), asn1SccMyChoice_b_get(val2)) else False));

end asn1SccMyChoice_Equal;

 

END TASTE_Dataview;