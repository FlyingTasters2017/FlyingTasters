-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH TASTE_BasicTypes;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview IS


SUBTYPE MyChoice_a_pattern_array_range is Natural range 1..1;
SUBTYPE MyChoice_a_pattern_array is adaasn1rtl.BitArray(MyChoice_a_pattern_array_range);
MyChoice_a_pattern:CONSTANT MyChoice_a_pattern_array := MyChoice_a_pattern_array'(
                                                                                  1=>1);

SUBTYPE MyBool_pattern_array_range is Natural range 1..1;
SUBTYPE MyBool_pattern_array is adaasn1rtl.BitArray(MyBool_pattern_array_range);
MyBool_pattern:CONSTANT MyBool_pattern_array := MyBool_pattern_array'(1=>1);

FUNCTION asn1SccMyInteger_Init return asn1SccMyInteger
IS 
BEGIN
    RETURN 0;
END asn1SccMyInteger_Init;

FUNCTION asn1SccMyInteger_IsConstraintValid(val : in asn1SccMyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- TASTE-BasicTypes.T-UInt8-------
-- TASTE-BasicTypes.T-UInt8


    ret := TASTE_BasicTypes.asn1SccT_UInt8_IsConstraintValid(val);
    RETURN ret;
END asn1SccMyInteger_IsConstraintValid;

function asn1SccMyInteger_Equal(val1, val2: in asn1SccMyInteger) return Boolean
is
begin
    return TASTE_BasicTypes.asn1SccT_UInt8_Equal(val1, val2);
end asn1SccMyInteger_Equal;

FUNCTION asn1SccMyReal_Init return asn1SccMyReal
IS 
BEGIN
    RETURN 0.00000000000000000000E+000;
END asn1SccMyReal_Init;

FUNCTION asn1SccMyReal_IsConstraintValid(val : in asn1SccMyReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- REAL (0.00000000000000000000E+000 .. 1.00000000000000000000E+003)-------
-- REAL (0.00000000000000000000E+000 .. 1.00000000000000000000E+003)


    ret := adaasn1rtl.ASN1_RESULT'(Success => (0.00000000000000000000E+000 <= val AND val <= 1.00000000000000000000E+003), ErrorCode => ERR_asn1SccMyReal);
    RETURN ret;
END asn1SccMyReal_IsConstraintValid;

function asn1SccMyReal_Equal(val1, val2: in asn1SccMyReal) return Boolean
is
begin
    return Asn1Real_Equal(val1, val2);
end asn1SccMyReal_Equal;

FUNCTION asn1SccMyPWM_Init return asn1SccMyPWM
IS 
BEGIN
    RETURN asn1SccMyPWM'(
    pwm1 => 0.00000000000000000000E+000,
    pwm2 => 0.00000000000000000000E+000,
    pwm3 => 0.00000000000000000000E+000,
    pwm4 => 0.00000000000000000000E+000
    );
END asn1SccMyPWM_Init;

FUNCTION asn1SccMyPWM_IsConstraintValid(val : in asn1SccMyPWM) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- SEQUENCE {
--     pwm1            MyReal ,
--     pwm2            MyReal ,
--     pwm3            MyReal ,
--     pwm4            MyReal 
-- } -------
-- SEQUENCE {
--     pwm1            MyReal ,
--     pwm2            MyReal ,
--     pwm3            MyReal ,
--     pwm4            MyReal 
-- } 


    ret := asn1SccMyReal_IsConstraintValid(val.pwm1);
    IF ret.Success THEN
        ret := asn1SccMyReal_IsConstraintValid(val.pwm2);
        IF ret.Success THEN
            ret := asn1SccMyReal_IsConstraintValid(val.pwm3);
            IF ret.Success THEN
                ret := asn1SccMyReal_IsConstraintValid(val.pwm4);
                IF ret.Success THEN
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END asn1SccMyPWM_IsConstraintValid;

function asn1SccMyPWM_Equal(val1, val2: in asn1SccMyPWM) return Boolean
is
begin
    return asn1SccMyReal_Equal(val1.pwm1, val2.pwm1) and asn1SccMyReal_Equal(val1.pwm2, val2.pwm2) and asn1SccMyReal_Equal(val1.pwm3, val2.pwm3) and asn1SccMyReal_Equal(val1.pwm4, val2.pwm4);
end asn1SccMyPWM_Equal;

FUNCTION asn1SccMyTrajectory_Init return asn1SccMyTrajectory
IS 
BEGIN
    RETURN asn1SccMyTrajectory'(
    x => 0.00000000000000000000E+000,
    y => 0.00000000000000000000E+000,
    z => 0.00000000000000000000E+000,
    yaw => 0.00000000000000000000E+000
    );
END asn1SccMyTrajectory_Init;

FUNCTION asn1SccMyTrajectory_IsConstraintValid(val : in asn1SccMyTrajectory) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- SEQUENCE {
--     x               MyReal ,
--     y               MyReal ,
--     z               MyReal ,
--     yaw             MyReal 
-- } -------
-- SEQUENCE {
--     x               MyReal ,
--     y               MyReal ,
--     z               MyReal ,
--     yaw             MyReal 
-- } 


    ret := asn1SccMyReal_IsConstraintValid(val.x);
    IF ret.Success THEN
        ret := asn1SccMyReal_IsConstraintValid(val.y);
        IF ret.Success THEN
            ret := asn1SccMyReal_IsConstraintValid(val.z);
            IF ret.Success THEN
                ret := asn1SccMyReal_IsConstraintValid(val.yaw);
                IF ret.Success THEN
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END asn1SccMyTrajectory_IsConstraintValid;

function asn1SccMyTrajectory_Equal(val1, val2: in asn1SccMyTrajectory) return Boolean
is
begin
    return asn1SccMyReal_Equal(val1.x, val2.x) and asn1SccMyReal_Equal(val1.y, val2.y) and asn1SccMyReal_Equal(val1.z, val2.z) and asn1SccMyReal_Equal(val1.yaw, val2.yaw);
end asn1SccMyTrajectory_Equal;

FUNCTION asn1SccMyStates_Init return asn1SccMyStates
IS 
BEGIN
    RETURN asn1SccMyStates'(
    x => 0.00000000000000000000E+000,
    y => 0.00000000000000000000E+000,
    z => 0.00000000000000000000E+000,
    yaw => 0.00000000000000000000E+000,
    pitch => 0.00000000000000000000E+000,
    roll => 0.00000000000000000000E+000,
    dx => 0.00000000000000000000E+000,
    dy => 0.00000000000000000000E+000,
    dz => 0.00000000000000000000E+000,
    dyaw => 0.00000000000000000000E+000,
    dpitch => 0.00000000000000000000E+000,
    droll => 0.00000000000000000000E+000
    );
END asn1SccMyStates_Init;

FUNCTION asn1SccMyStates_IsConstraintValid(val : in asn1SccMyStates) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- SEQUENCE {
--     x               MyReal ,
--     y               MyReal ,
--     z               MyReal ,
--     yaw             MyReal ,
--     pitch           MyReal ,
--     roll            MyReal ,
--     dx              MyReal ,
--     dy              MyReal ,
--     dz              MyReal ,
--     dyaw            MyReal ,
--     dpitch          MyReal ,
--     droll           MyReal 
-- } -------
-- SEQUENCE {
--     x               MyReal ,
--     y               MyReal ,
--     z               MyReal ,
--     yaw             MyReal ,
--     pitch           MyReal ,
--     roll            MyReal ,
--     dx              MyReal ,
--     dy              MyReal ,
--     dz              MyReal ,
--     dyaw            MyReal ,
--     dpitch          MyReal ,
--     droll           MyReal 
-- } 


    ret := asn1SccMyReal_IsConstraintValid(val.x);
    IF ret.Success THEN
        ret := asn1SccMyReal_IsConstraintValid(val.y);
        IF ret.Success THEN
            ret := asn1SccMyReal_IsConstraintValid(val.z);
            IF ret.Success THEN
                ret := asn1SccMyReal_IsConstraintValid(val.yaw);
                IF ret.Success THEN
                    ret := asn1SccMyReal_IsConstraintValid(val.pitch);
                    IF ret.Success THEN
                        ret := asn1SccMyReal_IsConstraintValid(val.roll);
                        IF ret.Success THEN
                            ret := asn1SccMyReal_IsConstraintValid(val.dx);
                            IF ret.Success THEN
                                ret := asn1SccMyReal_IsConstraintValid(val.dy);
                                IF ret.Success THEN
                                    ret := asn1SccMyReal_IsConstraintValid(val.dz);
                                    IF ret.Success THEN
                                        ret := asn1SccMyReal_IsConstraintValid(val.dyaw);
                                        IF ret.Success THEN
                                            ret := asn1SccMyReal_IsConstraintValid(val.dpitch);
                                            IF ret.Success THEN
                                                ret := asn1SccMyReal_IsConstraintValid(val.droll);
                                                IF ret.Success THEN
                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
                                                END IF;
                                            END IF;
                                        END IF;
                                    END IF;
                                END IF;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END asn1SccMyStates_IsConstraintValid;

function asn1SccMyStates_Equal(val1, val2: in asn1SccMyStates) return Boolean
is
begin
    return asn1SccMyReal_Equal(val1.x, val2.x) and asn1SccMyReal_Equal(val1.y, val2.y) and asn1SccMyReal_Equal(val1.z, val2.z) and asn1SccMyReal_Equal(val1.yaw, val2.yaw) and asn1SccMyReal_Equal(val1.pitch, val2.pitch) and asn1SccMyReal_Equal(val1.roll, val2.roll) and asn1SccMyReal_Equal(val1.dx, val2.dx) and asn1SccMyReal_Equal(val1.dy, val2.dy) and asn1SccMyReal_Equal(val1.dz, val2.dz) and asn1SccMyReal_Equal(val1.dyaw, val2.dyaw) and asn1SccMyReal_Equal(val1.dpitch, val2.dpitch) and asn1SccMyReal_Equal(val1.droll, val2.droll);
end asn1SccMyStates_Equal;

FUNCTION asn1SccMyBool_Init return asn1SccMyBool
IS 
BEGIN
    RETURN FALSE;
END asn1SccMyBool_Init;

function asn1SccMyBool_Equal(val1, val2: in asn1SccMyBool) return Boolean
is
begin
    return val1 = val2;
end asn1SccMyBool_Equal;

FUNCTION asn1SccMyEnum_Init return asn1SccMyEnum
IS 
BEGIN
    RETURN asn1Scchello;
END asn1SccMyEnum_Init;

FUNCTION asn1SccMyEnum_IsConstraintValid(val : in asn1SccMyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- ENUMERATED {
--     hello(0),
--     world(1),
--     howareyou(2)
-- } -------
-- ENUMERATED {
--     hello(0),
--     world(1),
--     howareyou(2)
-- } 


    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = asn1Scchello) OR (val = asn1Sccworld)) OR (val = asn1Scchowareyou)), ErrorCode => ERR_asn1SccMyEnum);
    RETURN ret;
END asn1SccMyEnum_IsConstraintValid;

function asn1SccMyEnum_Equal(val1, val2: in asn1SccMyEnum) return Boolean
is
begin
    return val1 = val2;
end asn1SccMyEnum_Equal;

FUNCTION asn1SccMySeqOf_Init return asn1SccMySeqOf
IS 
BEGIN
    RETURN asn1SccMySeqOf'(Data => asn1SccMySeqOf_array'( others => asn1Scchello));
END asn1SccMySeqOf_Init;

FUNCTION asn1SccMySeqOf_IsConstraintValid(val : in asn1SccMySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
    I1:Integer; 
 
BEGIN
-- SEQUENCE (SIZE(2)) OF MyEnum-------
-- SEQUENCE (SIZE(2)) OF MyEnum


    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
    I1 := 1;
    WHILE ret.Success AND I1<=2 LOOP
    --# assert I1 >= 1 AND I1 <= 2;
        ret := asn1SccMyEnum_IsConstraintValid(val.Data(I1));
        I1 := I1+1;
    END LOOP;
    RETURN ret;
END asn1SccMySeqOf_IsConstraintValid;

function asn1SccMySeqOf_Equal(val1, val2: in asn1SccMySeqOf) return Boolean
is
begin
    return (for all I in val1.Data'Range => asn1SccMyEnum_Equal(val1.Data(I), val2.Data(I)));	
end asn1SccMySeqOf_Equal;

FUNCTION asn1SccMyOctStr_Init return asn1SccMyOctStr
IS 
BEGIN
    RETURN asn1SccMyOctStr'(Data => asn1SccMyOctStr_array'(1=>16#00#, 2=>16#00#, 3=>16#00#, others=> 16#0#)) ;
END asn1SccMyOctStr_Init;

function asn1SccMyOctStr_Equal(val1, val2: in asn1SccMyOctStr) return Boolean
is
begin
    return val1.Data(val1.Data'Range) = val2.Data(val2.Data'Range);	
end asn1SccMyOctStr_Equal;

FUNCTION asn1SccMySeq_validity_Init return asn1SccMySeq_validity
IS 
BEGIN
    RETURN asn1Sccvalid;
END asn1SccMySeq_validity_Init;

FUNCTION asn1SccMySeq_validity_IsConstraintValid(val : in asn1SccMySeq_validity) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- ENUMERATED {
--     valid(0),
--     invalid(1)
-- } -------
-- ENUMERATED {
--     valid(0),
--     invalid(1)
-- } 


    ret := adaasn1rtl.ASN1_RESULT'(Success => ((val = asn1Sccvalid) OR (val = asn1Sccinvalid)), ErrorCode => ERR_asn1SccMySeq_validity);
    RETURN ret;
END asn1SccMySeq_validity_IsConstraintValid;

function asn1SccMySeq_validity_Equal(val1, val2: in asn1SccMySeq_validity) return Boolean
is
begin
    return val1 = val2;
end asn1SccMySeq_validity_Equal;

FUNCTION asn1SccMySeq_Init return asn1SccMySeq
IS 
BEGIN
    RETURN asn1SccMySeq'(
    input_data => 0,
    output_data => 0,
    validity => asn1Sccvalid
    );
END asn1SccMySeq_Init;

FUNCTION asn1SccMySeq_IsConstraintValid(val : in asn1SccMySeq) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- SEQUENCE {
--     input-data      MyInteger ,
--     output-data     MyInteger ,
--     validity        MySeq-validity 
-- } -------
-- SEQUENCE {
--     input-data      MyInteger ,
--     output-data     MyInteger ,
--     validity        MySeq-validity 
-- } 


    ret := asn1SccMyInteger_IsConstraintValid(val.input_data);
    IF ret.Success THEN
        ret := asn1SccMyInteger_IsConstraintValid(val.output_data);
        IF ret.Success THEN
            ret := asn1SccMySeq_validity_IsConstraintValid(val.validity);
            IF ret.Success THEN
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
            END IF;
        END IF;
    END IF;
    RETURN ret;
END asn1SccMySeq_IsConstraintValid;

function asn1SccMySeq_Equal(val1, val2: in asn1SccMySeq) return Boolean
is
begin
    return asn1SccMyInteger_Equal(val1.input_data, val2.input_data) and asn1SccMyInteger_Equal(val1.output_data, val2.output_data) and asn1SccMySeq_validity_Equal(val1.validity, val2.validity);
end asn1SccMySeq_Equal;

FUNCTION asn1SccMyChoice_kind(val:asn1SccMyChoice) RETURN asn1SccMyChoice_selection 
IS --# hide asn1SccMyChoice_kind;
BEGIN
    return val.kind;
END asn1SccMyChoice_kind;

FUNCTION asn1SccMyChoice_a_get(val:asn1SccMyChoice) RETURN adaasn1rtl.Asn1Boolean
IS --# hide asn1SccMyChoice_a_get;
BEGIN
    RETURN val.a;
END asn1SccMyChoice_a_get;

FUNCTION asn1SccMyChoice_a_set(itm:adaasn1rtl.Asn1Boolean) RETURN asn1SccMyChoice
IS --# hide asn1SccMyChoice_a_set;
BEGIN
    RETURN asn1SccMyChoice'(kind => a_PRESENT, a => itm);
END asn1SccMyChoice_a_set;
FUNCTION asn1SccMyChoice_b_get(val:asn1SccMyChoice) RETURN asn1SccMySeq
IS --# hide asn1SccMyChoice_b_get;
BEGIN
    RETURN val.b;
END asn1SccMyChoice_b_get;

FUNCTION asn1SccMyChoice_b_set(itm:asn1SccMySeq) RETURN asn1SccMyChoice
IS --# hide asn1SccMyChoice_b_set;
BEGIN
    RETURN asn1SccMyChoice'(kind => b_PRESENT, b => itm);
END asn1SccMyChoice_b_set;

FUNCTION asn1SccMyChoice_Init return asn1SccMyChoice
IS --#hide asn1SccMyChoice_Init;
BEGIN
    RETURN asn1SccMyChoice_a_set(FALSE);
END asn1SccMyChoice_Init;

FUNCTION asn1SccMyChoice_IsConstraintValid(val : in asn1SccMyChoice) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
 
 
BEGIN
-- CHOICE {
--     a               BOOLEAN ,
--     b               MySeq
-- } -------
-- CHOICE {
--     a               BOOLEAN ,
--     b               MySeq
-- } 


    CASE asn1SccMyChoice_kind(val) IS
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
        WHEN b_PRESENT =>
            ret := asn1SccMySeq_IsConstraintValid(asn1SccMyChoice_b_get(val));
    END CASE;
    RETURN ret;
END asn1SccMyChoice_IsConstraintValid;

function asn1SccMyChoice_Equal(val1, val2: in asn1SccMyChoice) return Boolean
is
begin
    return asn1SccMyChoice_kind(val1) = asn1SccMyChoice_kind(val2) and then
    ((if asn1SccMyChoice_kind(val1) = a_PRESENT then
 Asn1Boolean_Equal(asn1SccMyChoice_a_get(val1), asn1SccMyChoice_a_get(val2)) else False) or 
(if asn1SccMyChoice_kind(val1) = b_PRESENT then
 asn1SccMySeq_Equal(asn1SccMyChoice_b_get(val1), asn1SccMyChoice_b_get(val2)) else False));

end asn1SccMyChoice_Equal;

 

END TASTE_Dataview;