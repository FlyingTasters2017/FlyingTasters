-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
WITH System;
--# inherit adaasn1rtl;


PACKAGE TASTE_BasicTypes
IS


-----------------------------------------------------------asn1SccT_Int32-------------------------------------------------------------
SUBTYPE asn1SccT_Int32 IS adaasn1rtl.Asn1Int range -2147483648..2147483647;

asn1SccT_Int32_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 4;
asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 32;
asn1SccT_Int32_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 4;
asn1SccT_Int32_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 32;
asn1SccT_Int32_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION asn1SccT_Int32_Init return asn1SccT_Int32;
---# derives val from;
FUNCTION asn1SccT_Int32_IsConstraintValid(val : in asn1SccT_Int32) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;

SUBTYPE asn1SccT_Int32_uPER_bit_array_range is Natural range 1..asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_Int32_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_Int32_uPER_bit_array_range);

TYPE asn1SccT_Int32_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_Int32_uPER_bit_array;
END RECORD;
PROCEDURE asn1SccT_Int32_uPER_Encode(val:in asn1SccT_Int32; Stream : OUT asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE asn1SccT_Int32_uPER_Decode(val: out asn1SccT_Int32; Stream : IN asn1SccT_Int32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE asn1SccT_Int32_uPER_Encode_aux(val:in asn1SccT_Int32; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE asn1SccT_Int32_uPER_Decode_aux(val: out asn1SccT_Int32; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+asn1SccT_Int32_REQUIRED_BITS_FOR_ENCODING;

ERR_asn1SccT_Int32:CONSTANT INTEGER := 1011; -- (-2147483648 .. 2147483647)

-----------------------------------------------------------asn1SccT_UInt32-------------------------------------------------------------
SUBTYPE asn1SccT_UInt32 IS adaasn1rtl.Asn1Int range 0..4294967295;

asn1SccT_UInt32_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 4;
asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 32;
asn1SccT_UInt32_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 4;
asn1SccT_UInt32_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 32;
asn1SccT_UInt32_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION asn1SccT_UInt32_Init return asn1SccT_UInt32;
---# derives val from;
FUNCTION asn1SccT_UInt32_IsConstraintValid(val : in asn1SccT_UInt32) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;

SUBTYPE asn1SccT_UInt32_uPER_bit_array_range is Natural range 1..asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_UInt32_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_UInt32_uPER_bit_array_range);

TYPE asn1SccT_UInt32_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_UInt32_uPER_bit_array;
END RECORD;
PROCEDURE asn1SccT_UInt32_uPER_Encode(val:in asn1SccT_UInt32; Stream : OUT asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE asn1SccT_UInt32_uPER_Decode(val: out asn1SccT_UInt32; Stream : IN asn1SccT_UInt32_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE asn1SccT_UInt32_uPER_Encode_aux(val:in asn1SccT_UInt32; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE asn1SccT_UInt32_uPER_Decode_aux(val: out asn1SccT_UInt32; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+asn1SccT_UInt32_REQUIRED_BITS_FOR_ENCODING;

ERR_asn1SccT_UInt32:CONSTANT INTEGER := 1012; -- (0 .. 4294967295)

-----------------------------------------------------------asn1SccT_Int8-------------------------------------------------------------
SUBTYPE asn1SccT_Int8 IS adaasn1rtl.Asn1Int range -128..127;

asn1SccT_Int8_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 8;
asn1SccT_Int8_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Int8_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 8;
asn1SccT_Int8_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION asn1SccT_Int8_Init return asn1SccT_Int8;
---# derives val from;
FUNCTION asn1SccT_Int8_IsConstraintValid(val : in asn1SccT_Int8) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;

SUBTYPE asn1SccT_Int8_uPER_bit_array_range is Natural range 1..asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_Int8_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_Int8_uPER_bit_array_range);

TYPE asn1SccT_Int8_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_Int8_uPER_bit_array;
END RECORD;
PROCEDURE asn1SccT_Int8_uPER_Encode(val:in asn1SccT_Int8; Stream : OUT asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE asn1SccT_Int8_uPER_Decode(val: out asn1SccT_Int8; Stream : IN asn1SccT_Int8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE asn1SccT_Int8_uPER_Encode_aux(val:in asn1SccT_Int8; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE asn1SccT_Int8_uPER_Decode_aux(val: out asn1SccT_Int8; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+asn1SccT_Int8_REQUIRED_BITS_FOR_ENCODING;

ERR_asn1SccT_Int8:CONSTANT INTEGER := 1013; -- (-128 .. 127)

-----------------------------------------------------------asn1SccT_UInt8-------------------------------------------------------------
SUBTYPE asn1SccT_UInt8 IS adaasn1rtl.Asn1Int range 0..255;

asn1SccT_UInt8_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 8;
asn1SccT_UInt8_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_UInt8_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 8;
asn1SccT_UInt8_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION asn1SccT_UInt8_Init return asn1SccT_UInt8;
---# derives val from;
FUNCTION asn1SccT_UInt8_IsConstraintValid(val : in asn1SccT_UInt8) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;

SUBTYPE asn1SccT_UInt8_uPER_bit_array_range is Natural range 1..asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_UInt8_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_UInt8_uPER_bit_array_range);

TYPE asn1SccT_UInt8_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_UInt8_uPER_bit_array;
END RECORD;
PROCEDURE asn1SccT_UInt8_uPER_Encode(val:in asn1SccT_UInt8; Stream : OUT asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE asn1SccT_UInt8_uPER_Decode(val: out asn1SccT_UInt8; Stream : IN asn1SccT_UInt8_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE asn1SccT_UInt8_uPER_Encode_aux(val:in asn1SccT_UInt8; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE asn1SccT_UInt8_uPER_Decode_aux(val: out asn1SccT_UInt8; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+asn1SccT_UInt8_REQUIRED_BITS_FOR_ENCODING;

ERR_asn1SccT_UInt8:CONSTANT INTEGER := 1014; -- (0 .. 255)

-----------------------------------------------------------asn1SccT_Boolean-------------------------------------------------------------
SUBTYPE asn1SccT_Boolean IS adaasn1rtl.Asn1Boolean;

asn1SccT_Boolean_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Boolean_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Boolean_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
asn1SccT_Boolean_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION asn1SccT_Boolean_Init return asn1SccT_Boolean;
---# derives val from;

SUBTYPE asn1SccT_Boolean_uPER_bit_array_range is Natural range 1..asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE asn1SccT_Boolean_uPER_bit_array is adaasn1rtl.BitArray(asn1SccT_Boolean_uPER_bit_array_range);

TYPE asn1SccT_Boolean_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : asn1SccT_Boolean_uPER_bit_array;
END RECORD;
PROCEDURE asn1SccT_Boolean_uPER_Encode(val:in asn1SccT_Boolean; Stream : OUT asn1SccT_Boolean_uPER_Stream);
--# derives Stream from val;
PROCEDURE asn1SccT_Boolean_uPER_Decode(val: out asn1SccT_Boolean; Stream : IN asn1SccT_Boolean_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE asn1SccT_Boolean_uPER_Encode_aux(val:in asn1SccT_Boolean; S : in out adaasn1rtl.BitArray; K : in out Natural);
--# derives S from S , K, val & K from K;
--# pre K+1>= S'First and K + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE asn1SccT_Boolean_uPER_Decode_aux(val: out asn1SccT_Boolean; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K;
--# pre K.K+1>= S'First and K.K + asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+asn1SccT_Boolean_REQUIRED_BITS_FOR_ENCODING;



 

private
   --# hide TASTE_BasicTypes;


END TASTE_BasicTypes;